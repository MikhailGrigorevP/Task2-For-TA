Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements_group -> BEGIN statements END
Rule 3     statements_group -> inner_statement
Rule 4     inner_statement -> declaration
Rule 5     inner_statement -> assignment
Rule 6     inner_statement -> while
Rule 7     inner_statement -> if
Rule 8     inner_statement -> command
Rule 9     inner_statement -> function
Rule 10    inner_statement -> call
Rule 11    inner_statement -> RETURN expression
Rule 12    inner_statement -> empty
Rule 13    statements -> statements statement
Rule 14    statements -> statement
Rule 15    statement -> declaration NEWLINE
Rule 16    statement -> comment NEWLINE
Rule 17    statement -> assignment NEWLINE
Rule 18    statement -> while NEWLINE
Rule 19    statement -> if NEWLINE
Rule 20    statement -> command NEWLINE
Rule 21    statement -> function NEWLINE
Rule 22    statement -> call NEWLINE
Rule 23    statement -> RETURN expression NEWLINE
Rule 24    statement -> empty NEWLINE
Rule 25    statement -> error
Rule 26    declaration -> type variables
Rule 27    declaration -> type error
Rule 28    comment -> COMMENT any
Rule 29    any -> any VARIABLE
Rule 30    any -> VARIABLE
Rule 31    type -> INTEGER
Rule 32    type -> STRING
Rule 33    type -> BOOL
Rule 34    type -> VECTOR OF type
Rule 35    variables -> variable COMMA variables
Rule 36    variables -> assignment COMMA variables
Rule 37    variables -> variable
Rule 38    variables -> assignment
Rule 39    assignment -> variable ASSIGNMENT expression
Rule 40    assignment -> variable ASSIGNMENT assignment
Rule 41    assignment -> variable ASSIGNMENT error
Rule 42    variable -> VARIABLE indexing
Rule 43    variable -> VARIABLE
Rule 44    indexing -> L_QBRACKET expression R_QBRACKET indexing
Rule 45    indexing -> L_QBRACKET expression R_QBRACKET
Rule 46    expression -> variable
Rule 47    expression -> const
Rule 48    expression -> qstring
Rule 49    expression -> math_expression
Rule 50    expression -> robot_command
Rule 51    expression -> converting_command
Rule 52    expression -> vector_pop
Rule 53    expression -> call
Rule 54    qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE
Rule 55    qstring -> QUOTE string QUOTE
Rule 56    string -> VARIABLE string
Rule 57    string -> DECIMAL string
Rule 58    string -> FALSE string
Rule 59    string -> TRUE string
Rule 60    string -> FALSE
Rule 61    string -> TRUE
Rule 62    string -> DECIMAL
Rule 63    string -> VARIABLE
Rule 64    const -> TRUE
Rule 65    const -> FALSE
Rule 66    const -> UNDEFINED
Rule 67    const -> DECIMAL
Rule 68    const -> EXIT
Rule 69    const -> WOOD
Rule 70    const -> STEEL
Rule 71    const -> GLASS
Rule 72    const -> CONCRETE
Rule 73    const -> PLASTIC
Rule 74    math_expression -> expression LESS expression
Rule 75    math_expression -> expression GREATER expression
Rule 76    math_expression -> expression EQ expression
Rule 77    math_expression -> expression NOTEQ expression
Rule 78    math_expression -> expression PLUS expression
Rule 79    math_expression -> expression MINUS expression
Rule 80    while -> DO statements_group UNTIL expression
Rule 81    while -> DO error
Rule 82    if -> IF expression THEN statements_group
Rule 83    if -> IF expression THEN statements_group ELSE statements_group
Rule 84    if -> IF error
Rule 85    function -> FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
Rule 86    function -> FUNCTION OF type VARIABLE BRACKETS statements_group
Rule 87    function -> FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
Rule 88    function -> FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
Rule 89    function -> FUNCTION error
Rule 90    command -> vector_command
Rule 91    command -> robot_command
Rule 92    command -> vector_command error
Rule 93    command -> robot_command error
Rule 94    converting_command -> expression TO type
Rule 95    converting_command -> expression TO expression
Rule 96    converting_command -> expression TO vector_of
Rule 97    vector_of -> VECTOR OF vector_of
Rule 98    vector_of -> VECTOR
Rule 99    vector_command -> variable PUSH BACK expression
Rule 100   vector_command -> variable PUSH FRONT expression
Rule 101   vector_command -> variable PUSH BACK error
Rule 102   vector_command -> variable PUSH FRONT error
Rule 103   vector_pop -> variable POP BACK
Rule 104   vector_pop -> variable POP FRONT
Rule 105   robot_command -> LEFT
Rule 106   robot_command -> RIGHT
Rule 107   robot_command -> FORWARD
Rule 108   robot_command -> BACK
Rule 109   robot_command -> ROTATE_RIGHT
Rule 110   robot_command -> ROTATE_LEFT
Rule 111   robot_command -> LMS
Rule 112   robot_command -> REFLECT
Rule 113   robot_command -> DRILL
Rule 114   call -> VARIABLE LBRACKET parameters RBRACKET
Rule 115   call -> VARIABLE BRACKETS
Rule 116   call -> VARIABLE LBRACKET error RBRACKET
Rule 117   empty -> <empty>
Rule 118   parameters -> parameters COMMA parameter
Rule 119   parameters -> parameter
Rule 120   parameter -> expression
Rule 121   parameter -> VARIABLE EQ expression

Terminals, with rules where they appear

ASSIGNMENT           : 39 40 41
BACK                 : 99 101 103 108
BEGIN                : 2
BOOL                 : 33
BRACKETS             : 86 115
COMMA                : 35 36 118
COMMENT              : 28
CONCRETE             : 72
CONTINUE             : 87 88
DECIMAL              : 57 62 67
DO                   : 80 81
DOUBLE_QUOTE         : 54 54
DRILL                : 113
ELSE                 : 83
END                  : 2
EQ                   : 76 121
EXIT                 : 68
FALSE                : 58 60 65
FORWARD              : 107
FRONT                : 100 102 104
FUNCTION             : 85 86 87 88 89
GLASS                : 71
GREATER              : 75
IF                   : 82 83 84
INTEGER              : 31
LBRACKET             : 85 87 88 114 116
LEFT                 : 105
LESS                 : 74
LMS                  : 111
L_QBRACKET           : 44 45
MINUS                : 79
NEWLINE              : 15 16 17 18 19 20 21 22 23 24
NOTEQ                : 77
OF                   : 34 85 86 87 88 97
PLASTIC              : 73
PLUS                 : 78
POP                  : 103 104
PUSH                 : 99 100 101 102
QUOTE                : 55 55
RBRACKET             : 85 87 88 114 116
REFLECT              : 112
RETURN               : 11 23
RIGHT                : 106
ROTATE_LEFT          : 110
ROTATE_RIGHT         : 109
R_QBRACKET           : 44 45
STEEL                : 70
STRING               : 32
THEN                 : 82 83
TO                   : 94 95 96
TRUE                 : 59 61 64
UNDEFINED            : 66
UNTIL                : 80
VARIABLE             : 29 30 42 43 56 63 85 86 87 88 114 115 116 121
VECTOR               : 34 97 98
WOOD                 : 69
error                : 25 27 41 81 84 89 92 93 101 102 116

Nonterminals, with rules where they appear

any                  : 28 29
assignment           : 5 17 36 38 40
call                 : 10 22 53
command              : 8 20
comment              : 16
const                : 47
converting_command   : 51
declaration          : 4 15
empty                : 12 24
expression           : 11 23 39 44 45 74 74 75 75 76 76 77 77 78 78 79 79 80 82 83 94 95 95 96 99 100 120 121
function             : 9 21
if                   : 7 19
indexing             : 42 44
inner_statement      : 3
math_expression      : 49
parameter            : 118 119
parameters           : 85 87 114 118
program              : 0
qstring              : 48
robot_command        : 50 91 93
statement            : 13 14
statements           : 1 2 13
statements_group     : 80 82 83 83 85 86 87 88
string               : 54 55 56 57 58 59
type                 : 26 27 34 85 86 87 88 94
variable             : 35 37 39 40 41 46 99 100 101 102 103 104
variables            : 26 35 36
vector_command       : 90 92
vector_of            : 96 97
vector_pop           : 52
while                : 6 18

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (13) statements -> . statements statement
    (14) statements -> . statement
    (15) statement -> . declaration NEWLINE
    (16) statement -> . comment NEWLINE
    (17) statement -> . assignment NEWLINE
    (18) statement -> . while NEWLINE
    (19) statement -> . if NEWLINE
    (20) statement -> . command NEWLINE
    (21) statement -> . function NEWLINE
    (22) statement -> . call NEWLINE
    (23) statement -> . RETURN expression NEWLINE
    (24) statement -> . empty NEWLINE
    (25) statement -> . error
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (28) comment -> . COMMENT any
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    RETURN          shift and go to state 12
    error           shift and go to state 14
    COMMENT         shift and go to state 16
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    NEWLINE         reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    comment                        shift and go to state 5
    assignment                     shift and go to state 6
    while                          shift and go to state 7
    if                             shift and go to state 8
    command                        shift and go to state 9
    function                       shift and go to state 10
    call                           shift and go to state 11
    empty                          shift and go to state 13
    type                           shift and go to state 15
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 1

    (0) S' -> program .



state 2

    (1) program -> statements .
    (13) statements -> statements . statement
    (15) statement -> . declaration NEWLINE
    (16) statement -> . comment NEWLINE
    (17) statement -> . assignment NEWLINE
    (18) statement -> . while NEWLINE
    (19) statement -> . if NEWLINE
    (20) statement -> . command NEWLINE
    (21) statement -> . function NEWLINE
    (22) statement -> . call NEWLINE
    (23) statement -> . RETURN expression NEWLINE
    (24) statement -> . empty NEWLINE
    (25) statement -> . error
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (28) comment -> . COMMENT any
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    $end            reduce using rule 1 (program -> statements .)
    RETURN          shift and go to state 12
    error           shift and go to state 14
    COMMENT         shift and go to state 16
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    NEWLINE         reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    statement                      shift and go to state 37
    declaration                    shift and go to state 4
    comment                        shift and go to state 5
    assignment                     shift and go to state 6
    while                          shift and go to state 7
    if                             shift and go to state 8
    command                        shift and go to state 9
    function                       shift and go to state 10
    call                           shift and go to state 11
    empty                          shift and go to state 13
    type                           shift and go to state 15
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 3

    (14) statements -> statement .

    RETURN          reduce using rule 14 (statements -> statement .)
    error           reduce using rule 14 (statements -> statement .)
    COMMENT         reduce using rule 14 (statements -> statement .)
    DO              reduce using rule 14 (statements -> statement .)
    IF              reduce using rule 14 (statements -> statement .)
    FUNCTION        reduce using rule 14 (statements -> statement .)
    VARIABLE        reduce using rule 14 (statements -> statement .)
    INTEGER         reduce using rule 14 (statements -> statement .)
    STRING          reduce using rule 14 (statements -> statement .)
    BOOL            reduce using rule 14 (statements -> statement .)
    VECTOR          reduce using rule 14 (statements -> statement .)
    LEFT            reduce using rule 14 (statements -> statement .)
    RIGHT           reduce using rule 14 (statements -> statement .)
    FORWARD         reduce using rule 14 (statements -> statement .)
    BACK            reduce using rule 14 (statements -> statement .)
    ROTATE_RIGHT    reduce using rule 14 (statements -> statement .)
    ROTATE_LEFT     reduce using rule 14 (statements -> statement .)
    LMS             reduce using rule 14 (statements -> statement .)
    REFLECT         reduce using rule 14 (statements -> statement .)
    DRILL           reduce using rule 14 (statements -> statement .)
    NEWLINE         reduce using rule 14 (statements -> statement .)
    $end            reduce using rule 14 (statements -> statement .)
    END             reduce using rule 14 (statements -> statement .)


state 4

    (15) statement -> declaration . NEWLINE

    NEWLINE         shift and go to state 38


state 5

    (16) statement -> comment . NEWLINE

    NEWLINE         shift and go to state 39


state 6

    (17) statement -> assignment . NEWLINE

    NEWLINE         shift and go to state 40


state 7

    (18) statement -> while . NEWLINE

    NEWLINE         shift and go to state 41


state 8

    (19) statement -> if . NEWLINE

    NEWLINE         shift and go to state 42


state 9

    (20) statement -> command . NEWLINE

    NEWLINE         shift and go to state 43


state 10

    (21) statement -> function . NEWLINE

    NEWLINE         shift and go to state 44


state 11

    (22) statement -> call . NEWLINE

    NEWLINE         shift and go to state 45


state 12

    (23) statement -> RETURN . expression NEWLINE
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 46
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 13

    (24) statement -> empty . NEWLINE

    NEWLINE         shift and go to state 68


state 14

    (25) statement -> error .

    RETURN          reduce using rule 25 (statement -> error .)
    error           reduce using rule 25 (statement -> error .)
    COMMENT         reduce using rule 25 (statement -> error .)
    DO              reduce using rule 25 (statement -> error .)
    IF              reduce using rule 25 (statement -> error .)
    FUNCTION        reduce using rule 25 (statement -> error .)
    VARIABLE        reduce using rule 25 (statement -> error .)
    INTEGER         reduce using rule 25 (statement -> error .)
    STRING          reduce using rule 25 (statement -> error .)
    BOOL            reduce using rule 25 (statement -> error .)
    VECTOR          reduce using rule 25 (statement -> error .)
    LEFT            reduce using rule 25 (statement -> error .)
    RIGHT           reduce using rule 25 (statement -> error .)
    FORWARD         reduce using rule 25 (statement -> error .)
    BACK            reduce using rule 25 (statement -> error .)
    ROTATE_RIGHT    reduce using rule 25 (statement -> error .)
    ROTATE_LEFT     reduce using rule 25 (statement -> error .)
    LMS             reduce using rule 25 (statement -> error .)
    REFLECT         reduce using rule 25 (statement -> error .)
    DRILL           reduce using rule 25 (statement -> error .)
    NEWLINE         reduce using rule 25 (statement -> error .)
    $end            reduce using rule 25 (statement -> error .)
    END             reduce using rule 25 (statement -> error .)


state 15

    (26) declaration -> type . variables
    (27) declaration -> type . error
    (35) variables -> . variable COMMA variables
    (36) variables -> . assignment COMMA variables
    (37) variables -> . variable
    (38) variables -> . assignment
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error

    error           shift and go to state 70
    VARIABLE        shift and go to state 73

    variables                      shift and go to state 69
    variable                       shift and go to state 71
    assignment                     shift and go to state 72

state 16

    (28) comment -> COMMENT . any
    (29) any -> . any VARIABLE
    (30) any -> . VARIABLE

    VARIABLE        shift and go to state 75

    any                            shift and go to state 74

state 17

    (39) assignment -> variable . ASSIGNMENT expression
    (40) assignment -> variable . ASSIGNMENT assignment
    (41) assignment -> variable . ASSIGNMENT error
    (99) vector_command -> variable . PUSH BACK expression
    (100) vector_command -> variable . PUSH FRONT expression
    (101) vector_command -> variable . PUSH BACK error
    (102) vector_command -> variable . PUSH FRONT error

    ASSIGNMENT      shift and go to state 76
    PUSH            shift and go to state 77


state 18

    (80) while -> DO . statements_group UNTIL expression
    (81) while -> DO . error
    (2) statements_group -> . BEGIN statements END
    (3) statements_group -> . inner_statement
    (4) inner_statement -> . declaration
    (5) inner_statement -> . assignment
    (6) inner_statement -> . while
    (7) inner_statement -> . if
    (8) inner_statement -> . command
    (9) inner_statement -> . function
    (10) inner_statement -> . call
    (11) inner_statement -> . RETURN expression
    (12) inner_statement -> . empty
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    error           shift and go to state 79
    BEGIN           shift and go to state 80
    RETURN          shift and go to state 89
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    UNTIL           reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    statements_group               shift and go to state 78
    inner_statement                shift and go to state 81
    declaration                    shift and go to state 82
    assignment                     shift and go to state 83
    while                          shift and go to state 84
    if                             shift and go to state 85
    command                        shift and go to state 86
    function                       shift and go to state 87
    call                           shift and go to state 88
    empty                          shift and go to state 90
    type                           shift and go to state 15
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 19

    (82) if -> IF . expression THEN statements_group
    (83) if -> IF . expression THEN statements_group ELSE statements_group
    (84) if -> IF . error
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    error           shift and go to state 92
    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 91
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 20

    (90) command -> vector_command .
    (92) command -> vector_command . error

    NEWLINE         reduce using rule 90 (command -> vector_command .)
    UNTIL           reduce using rule 90 (command -> vector_command .)
    ELSE            reduce using rule 90 (command -> vector_command .)
    error           shift and go to state 93


state 21

    (91) command -> robot_command .
    (93) command -> robot_command . error

    NEWLINE         reduce using rule 91 (command -> robot_command .)
    UNTIL           reduce using rule 91 (command -> robot_command .)
    ELSE            reduce using rule 91 (command -> robot_command .)
    error           shift and go to state 94


state 22

    (85) function -> FUNCTION . OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> FUNCTION . OF type VARIABLE BRACKETS statements_group
    (87) function -> FUNCTION . OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> FUNCTION . OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> FUNCTION . error

    OF              shift and go to state 95
    error           shift and go to state 96


state 23

    (114) call -> VARIABLE . LBRACKET parameters RBRACKET
    (115) call -> VARIABLE . BRACKETS
    (116) call -> VARIABLE . LBRACKET error RBRACKET
    (42) variable -> VARIABLE . indexing
    (43) variable -> VARIABLE .
    (44) indexing -> . L_QBRACKET expression R_QBRACKET indexing
    (45) indexing -> . L_QBRACKET expression R_QBRACKET

    LBRACKET        shift and go to state 97
    BRACKETS        shift and go to state 98
    ASSIGNMENT      reduce using rule 43 (variable -> VARIABLE .)
    PUSH            reduce using rule 43 (variable -> VARIABLE .)
    L_QBRACKET      shift and go to state 100

    indexing                       shift and go to state 99

state 24

    (31) type -> INTEGER .

    error           reduce using rule 31 (type -> INTEGER .)
    VARIABLE        reduce using rule 31 (type -> INTEGER .)
    NEWLINE         reduce using rule 31 (type -> INTEGER .)
    LESS            reduce using rule 31 (type -> INTEGER .)
    GREATER         reduce using rule 31 (type -> INTEGER .)
    EQ              reduce using rule 31 (type -> INTEGER .)
    NOTEQ           reduce using rule 31 (type -> INTEGER .)
    PLUS            reduce using rule 31 (type -> INTEGER .)
    MINUS           reduce using rule 31 (type -> INTEGER .)
    TO              reduce using rule 31 (type -> INTEGER .)
    THEN            reduce using rule 31 (type -> INTEGER .)
    COMMA           reduce using rule 31 (type -> INTEGER .)
    UNTIL           reduce using rule 31 (type -> INTEGER .)
    ELSE            reduce using rule 31 (type -> INTEGER .)
    RBRACKET        reduce using rule 31 (type -> INTEGER .)
    R_QBRACKET      reduce using rule 31 (type -> INTEGER .)
    CONTINUE        reduce using rule 31 (type -> INTEGER .)


state 25

    (32) type -> STRING .

    error           reduce using rule 32 (type -> STRING .)
    VARIABLE        reduce using rule 32 (type -> STRING .)
    NEWLINE         reduce using rule 32 (type -> STRING .)
    LESS            reduce using rule 32 (type -> STRING .)
    GREATER         reduce using rule 32 (type -> STRING .)
    EQ              reduce using rule 32 (type -> STRING .)
    NOTEQ           reduce using rule 32 (type -> STRING .)
    PLUS            reduce using rule 32 (type -> STRING .)
    MINUS           reduce using rule 32 (type -> STRING .)
    TO              reduce using rule 32 (type -> STRING .)
    THEN            reduce using rule 32 (type -> STRING .)
    COMMA           reduce using rule 32 (type -> STRING .)
    UNTIL           reduce using rule 32 (type -> STRING .)
    ELSE            reduce using rule 32 (type -> STRING .)
    RBRACKET        reduce using rule 32 (type -> STRING .)
    R_QBRACKET      reduce using rule 32 (type -> STRING .)
    CONTINUE        reduce using rule 32 (type -> STRING .)


state 26

    (33) type -> BOOL .

    error           reduce using rule 33 (type -> BOOL .)
    VARIABLE        reduce using rule 33 (type -> BOOL .)
    NEWLINE         reduce using rule 33 (type -> BOOL .)
    LESS            reduce using rule 33 (type -> BOOL .)
    GREATER         reduce using rule 33 (type -> BOOL .)
    EQ              reduce using rule 33 (type -> BOOL .)
    NOTEQ           reduce using rule 33 (type -> BOOL .)
    PLUS            reduce using rule 33 (type -> BOOL .)
    MINUS           reduce using rule 33 (type -> BOOL .)
    TO              reduce using rule 33 (type -> BOOL .)
    THEN            reduce using rule 33 (type -> BOOL .)
    COMMA           reduce using rule 33 (type -> BOOL .)
    UNTIL           reduce using rule 33 (type -> BOOL .)
    ELSE            reduce using rule 33 (type -> BOOL .)
    RBRACKET        reduce using rule 33 (type -> BOOL .)
    R_QBRACKET      reduce using rule 33 (type -> BOOL .)
    CONTINUE        reduce using rule 33 (type -> BOOL .)


state 27

    (34) type -> VECTOR . OF type

    OF              shift and go to state 101


state 28

    (108) robot_command -> BACK .

    error           reduce using rule 108 (robot_command -> BACK .)
    NEWLINE         reduce using rule 108 (robot_command -> BACK .)
    LESS            reduce using rule 108 (robot_command -> BACK .)
    GREATER         reduce using rule 108 (robot_command -> BACK .)
    EQ              reduce using rule 108 (robot_command -> BACK .)
    NOTEQ           reduce using rule 108 (robot_command -> BACK .)
    PLUS            reduce using rule 108 (robot_command -> BACK .)
    MINUS           reduce using rule 108 (robot_command -> BACK .)
    TO              reduce using rule 108 (robot_command -> BACK .)
    UNTIL           reduce using rule 108 (robot_command -> BACK .)
    THEN            reduce using rule 108 (robot_command -> BACK .)
    COMMA           reduce using rule 108 (robot_command -> BACK .)
    ELSE            reduce using rule 108 (robot_command -> BACK .)
    RBRACKET        reduce using rule 108 (robot_command -> BACK .)
    R_QBRACKET      reduce using rule 108 (robot_command -> BACK .)
    CONTINUE        reduce using rule 108 (robot_command -> BACK .)


state 29

    (105) robot_command -> LEFT .

    error           reduce using rule 105 (robot_command -> LEFT .)
    NEWLINE         reduce using rule 105 (robot_command -> LEFT .)
    LESS            reduce using rule 105 (robot_command -> LEFT .)
    GREATER         reduce using rule 105 (robot_command -> LEFT .)
    EQ              reduce using rule 105 (robot_command -> LEFT .)
    NOTEQ           reduce using rule 105 (robot_command -> LEFT .)
    PLUS            reduce using rule 105 (robot_command -> LEFT .)
    MINUS           reduce using rule 105 (robot_command -> LEFT .)
    TO              reduce using rule 105 (robot_command -> LEFT .)
    UNTIL           reduce using rule 105 (robot_command -> LEFT .)
    THEN            reduce using rule 105 (robot_command -> LEFT .)
    COMMA           reduce using rule 105 (robot_command -> LEFT .)
    ELSE            reduce using rule 105 (robot_command -> LEFT .)
    RBRACKET        reduce using rule 105 (robot_command -> LEFT .)
    R_QBRACKET      reduce using rule 105 (robot_command -> LEFT .)
    CONTINUE        reduce using rule 105 (robot_command -> LEFT .)


state 30

    (106) robot_command -> RIGHT .

    error           reduce using rule 106 (robot_command -> RIGHT .)
    NEWLINE         reduce using rule 106 (robot_command -> RIGHT .)
    LESS            reduce using rule 106 (robot_command -> RIGHT .)
    GREATER         reduce using rule 106 (robot_command -> RIGHT .)
    EQ              reduce using rule 106 (robot_command -> RIGHT .)
    NOTEQ           reduce using rule 106 (robot_command -> RIGHT .)
    PLUS            reduce using rule 106 (robot_command -> RIGHT .)
    MINUS           reduce using rule 106 (robot_command -> RIGHT .)
    TO              reduce using rule 106 (robot_command -> RIGHT .)
    UNTIL           reduce using rule 106 (robot_command -> RIGHT .)
    THEN            reduce using rule 106 (robot_command -> RIGHT .)
    COMMA           reduce using rule 106 (robot_command -> RIGHT .)
    ELSE            reduce using rule 106 (robot_command -> RIGHT .)
    RBRACKET        reduce using rule 106 (robot_command -> RIGHT .)
    R_QBRACKET      reduce using rule 106 (robot_command -> RIGHT .)
    CONTINUE        reduce using rule 106 (robot_command -> RIGHT .)


state 31

    (107) robot_command -> FORWARD .

    error           reduce using rule 107 (robot_command -> FORWARD .)
    NEWLINE         reduce using rule 107 (robot_command -> FORWARD .)
    LESS            reduce using rule 107 (robot_command -> FORWARD .)
    GREATER         reduce using rule 107 (robot_command -> FORWARD .)
    EQ              reduce using rule 107 (robot_command -> FORWARD .)
    NOTEQ           reduce using rule 107 (robot_command -> FORWARD .)
    PLUS            reduce using rule 107 (robot_command -> FORWARD .)
    MINUS           reduce using rule 107 (robot_command -> FORWARD .)
    TO              reduce using rule 107 (robot_command -> FORWARD .)
    UNTIL           reduce using rule 107 (robot_command -> FORWARD .)
    THEN            reduce using rule 107 (robot_command -> FORWARD .)
    COMMA           reduce using rule 107 (robot_command -> FORWARD .)
    ELSE            reduce using rule 107 (robot_command -> FORWARD .)
    RBRACKET        reduce using rule 107 (robot_command -> FORWARD .)
    R_QBRACKET      reduce using rule 107 (robot_command -> FORWARD .)
    CONTINUE        reduce using rule 107 (robot_command -> FORWARD .)


state 32

    (109) robot_command -> ROTATE_RIGHT .

    error           reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    NEWLINE         reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    LESS            reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    GREATER         reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    EQ              reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    NOTEQ           reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    PLUS            reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    MINUS           reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    TO              reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    UNTIL           reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    THEN            reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    COMMA           reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    ELSE            reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    RBRACKET        reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    R_QBRACKET      reduce using rule 109 (robot_command -> ROTATE_RIGHT .)
    CONTINUE        reduce using rule 109 (robot_command -> ROTATE_RIGHT .)


state 33

    (110) robot_command -> ROTATE_LEFT .

    error           reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    NEWLINE         reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    LESS            reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    GREATER         reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    EQ              reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    NOTEQ           reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    PLUS            reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    MINUS           reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    TO              reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    UNTIL           reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    THEN            reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    COMMA           reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    ELSE            reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    RBRACKET        reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    R_QBRACKET      reduce using rule 110 (robot_command -> ROTATE_LEFT .)
    CONTINUE        reduce using rule 110 (robot_command -> ROTATE_LEFT .)


state 34

    (111) robot_command -> LMS .

    error           reduce using rule 111 (robot_command -> LMS .)
    NEWLINE         reduce using rule 111 (robot_command -> LMS .)
    LESS            reduce using rule 111 (robot_command -> LMS .)
    GREATER         reduce using rule 111 (robot_command -> LMS .)
    EQ              reduce using rule 111 (robot_command -> LMS .)
    NOTEQ           reduce using rule 111 (robot_command -> LMS .)
    PLUS            reduce using rule 111 (robot_command -> LMS .)
    MINUS           reduce using rule 111 (robot_command -> LMS .)
    TO              reduce using rule 111 (robot_command -> LMS .)
    UNTIL           reduce using rule 111 (robot_command -> LMS .)
    THEN            reduce using rule 111 (robot_command -> LMS .)
    COMMA           reduce using rule 111 (robot_command -> LMS .)
    ELSE            reduce using rule 111 (robot_command -> LMS .)
    RBRACKET        reduce using rule 111 (robot_command -> LMS .)
    R_QBRACKET      reduce using rule 111 (robot_command -> LMS .)
    CONTINUE        reduce using rule 111 (robot_command -> LMS .)


state 35

    (112) robot_command -> REFLECT .

    error           reduce using rule 112 (robot_command -> REFLECT .)
    NEWLINE         reduce using rule 112 (robot_command -> REFLECT .)
    LESS            reduce using rule 112 (robot_command -> REFLECT .)
    GREATER         reduce using rule 112 (robot_command -> REFLECT .)
    EQ              reduce using rule 112 (robot_command -> REFLECT .)
    NOTEQ           reduce using rule 112 (robot_command -> REFLECT .)
    PLUS            reduce using rule 112 (robot_command -> REFLECT .)
    MINUS           reduce using rule 112 (robot_command -> REFLECT .)
    TO              reduce using rule 112 (robot_command -> REFLECT .)
    UNTIL           reduce using rule 112 (robot_command -> REFLECT .)
    THEN            reduce using rule 112 (robot_command -> REFLECT .)
    COMMA           reduce using rule 112 (robot_command -> REFLECT .)
    ELSE            reduce using rule 112 (robot_command -> REFLECT .)
    RBRACKET        reduce using rule 112 (robot_command -> REFLECT .)
    R_QBRACKET      reduce using rule 112 (robot_command -> REFLECT .)
    CONTINUE        reduce using rule 112 (robot_command -> REFLECT .)


state 36

    (113) robot_command -> DRILL .

    error           reduce using rule 113 (robot_command -> DRILL .)
    NEWLINE         reduce using rule 113 (robot_command -> DRILL .)
    LESS            reduce using rule 113 (robot_command -> DRILL .)
    GREATER         reduce using rule 113 (robot_command -> DRILL .)
    EQ              reduce using rule 113 (robot_command -> DRILL .)
    NOTEQ           reduce using rule 113 (robot_command -> DRILL .)
    PLUS            reduce using rule 113 (robot_command -> DRILL .)
    MINUS           reduce using rule 113 (robot_command -> DRILL .)
    TO              reduce using rule 113 (robot_command -> DRILL .)
    UNTIL           reduce using rule 113 (robot_command -> DRILL .)
    THEN            reduce using rule 113 (robot_command -> DRILL .)
    COMMA           reduce using rule 113 (robot_command -> DRILL .)
    ELSE            reduce using rule 113 (robot_command -> DRILL .)
    RBRACKET        reduce using rule 113 (robot_command -> DRILL .)
    R_QBRACKET      reduce using rule 113 (robot_command -> DRILL .)
    CONTINUE        reduce using rule 113 (robot_command -> DRILL .)


state 37

    (13) statements -> statements statement .

    RETURN          reduce using rule 13 (statements -> statements statement .)
    error           reduce using rule 13 (statements -> statements statement .)
    COMMENT         reduce using rule 13 (statements -> statements statement .)
    DO              reduce using rule 13 (statements -> statements statement .)
    IF              reduce using rule 13 (statements -> statements statement .)
    FUNCTION        reduce using rule 13 (statements -> statements statement .)
    VARIABLE        reduce using rule 13 (statements -> statements statement .)
    INTEGER         reduce using rule 13 (statements -> statements statement .)
    STRING          reduce using rule 13 (statements -> statements statement .)
    BOOL            reduce using rule 13 (statements -> statements statement .)
    VECTOR          reduce using rule 13 (statements -> statements statement .)
    LEFT            reduce using rule 13 (statements -> statements statement .)
    RIGHT           reduce using rule 13 (statements -> statements statement .)
    FORWARD         reduce using rule 13 (statements -> statements statement .)
    BACK            reduce using rule 13 (statements -> statements statement .)
    ROTATE_RIGHT    reduce using rule 13 (statements -> statements statement .)
    ROTATE_LEFT     reduce using rule 13 (statements -> statements statement .)
    LMS             reduce using rule 13 (statements -> statements statement .)
    REFLECT         reduce using rule 13 (statements -> statements statement .)
    DRILL           reduce using rule 13 (statements -> statements statement .)
    NEWLINE         reduce using rule 13 (statements -> statements statement .)
    $end            reduce using rule 13 (statements -> statements statement .)
    END             reduce using rule 13 (statements -> statements statement .)


state 38

    (15) statement -> declaration NEWLINE .

    RETURN          reduce using rule 15 (statement -> declaration NEWLINE .)
    error           reduce using rule 15 (statement -> declaration NEWLINE .)
    COMMENT         reduce using rule 15 (statement -> declaration NEWLINE .)
    DO              reduce using rule 15 (statement -> declaration NEWLINE .)
    IF              reduce using rule 15 (statement -> declaration NEWLINE .)
    FUNCTION        reduce using rule 15 (statement -> declaration NEWLINE .)
    VARIABLE        reduce using rule 15 (statement -> declaration NEWLINE .)
    INTEGER         reduce using rule 15 (statement -> declaration NEWLINE .)
    STRING          reduce using rule 15 (statement -> declaration NEWLINE .)
    BOOL            reduce using rule 15 (statement -> declaration NEWLINE .)
    VECTOR          reduce using rule 15 (statement -> declaration NEWLINE .)
    LEFT            reduce using rule 15 (statement -> declaration NEWLINE .)
    RIGHT           reduce using rule 15 (statement -> declaration NEWLINE .)
    FORWARD         reduce using rule 15 (statement -> declaration NEWLINE .)
    BACK            reduce using rule 15 (statement -> declaration NEWLINE .)
    ROTATE_RIGHT    reduce using rule 15 (statement -> declaration NEWLINE .)
    ROTATE_LEFT     reduce using rule 15 (statement -> declaration NEWLINE .)
    LMS             reduce using rule 15 (statement -> declaration NEWLINE .)
    REFLECT         reduce using rule 15 (statement -> declaration NEWLINE .)
    DRILL           reduce using rule 15 (statement -> declaration NEWLINE .)
    NEWLINE         reduce using rule 15 (statement -> declaration NEWLINE .)
    $end            reduce using rule 15 (statement -> declaration NEWLINE .)
    END             reduce using rule 15 (statement -> declaration NEWLINE .)


state 39

    (16) statement -> comment NEWLINE .

    RETURN          reduce using rule 16 (statement -> comment NEWLINE .)
    error           reduce using rule 16 (statement -> comment NEWLINE .)
    COMMENT         reduce using rule 16 (statement -> comment NEWLINE .)
    DO              reduce using rule 16 (statement -> comment NEWLINE .)
    IF              reduce using rule 16 (statement -> comment NEWLINE .)
    FUNCTION        reduce using rule 16 (statement -> comment NEWLINE .)
    VARIABLE        reduce using rule 16 (statement -> comment NEWLINE .)
    INTEGER         reduce using rule 16 (statement -> comment NEWLINE .)
    STRING          reduce using rule 16 (statement -> comment NEWLINE .)
    BOOL            reduce using rule 16 (statement -> comment NEWLINE .)
    VECTOR          reduce using rule 16 (statement -> comment NEWLINE .)
    LEFT            reduce using rule 16 (statement -> comment NEWLINE .)
    RIGHT           reduce using rule 16 (statement -> comment NEWLINE .)
    FORWARD         reduce using rule 16 (statement -> comment NEWLINE .)
    BACK            reduce using rule 16 (statement -> comment NEWLINE .)
    ROTATE_RIGHT    reduce using rule 16 (statement -> comment NEWLINE .)
    ROTATE_LEFT     reduce using rule 16 (statement -> comment NEWLINE .)
    LMS             reduce using rule 16 (statement -> comment NEWLINE .)
    REFLECT         reduce using rule 16 (statement -> comment NEWLINE .)
    DRILL           reduce using rule 16 (statement -> comment NEWLINE .)
    NEWLINE         reduce using rule 16 (statement -> comment NEWLINE .)
    $end            reduce using rule 16 (statement -> comment NEWLINE .)
    END             reduce using rule 16 (statement -> comment NEWLINE .)


state 40

    (17) statement -> assignment NEWLINE .

    RETURN          reduce using rule 17 (statement -> assignment NEWLINE .)
    error           reduce using rule 17 (statement -> assignment NEWLINE .)
    COMMENT         reduce using rule 17 (statement -> assignment NEWLINE .)
    DO              reduce using rule 17 (statement -> assignment NEWLINE .)
    IF              reduce using rule 17 (statement -> assignment NEWLINE .)
    FUNCTION        reduce using rule 17 (statement -> assignment NEWLINE .)
    VARIABLE        reduce using rule 17 (statement -> assignment NEWLINE .)
    INTEGER         reduce using rule 17 (statement -> assignment NEWLINE .)
    STRING          reduce using rule 17 (statement -> assignment NEWLINE .)
    BOOL            reduce using rule 17 (statement -> assignment NEWLINE .)
    VECTOR          reduce using rule 17 (statement -> assignment NEWLINE .)
    LEFT            reduce using rule 17 (statement -> assignment NEWLINE .)
    RIGHT           reduce using rule 17 (statement -> assignment NEWLINE .)
    FORWARD         reduce using rule 17 (statement -> assignment NEWLINE .)
    BACK            reduce using rule 17 (statement -> assignment NEWLINE .)
    ROTATE_RIGHT    reduce using rule 17 (statement -> assignment NEWLINE .)
    ROTATE_LEFT     reduce using rule 17 (statement -> assignment NEWLINE .)
    LMS             reduce using rule 17 (statement -> assignment NEWLINE .)
    REFLECT         reduce using rule 17 (statement -> assignment NEWLINE .)
    DRILL           reduce using rule 17 (statement -> assignment NEWLINE .)
    NEWLINE         reduce using rule 17 (statement -> assignment NEWLINE .)
    $end            reduce using rule 17 (statement -> assignment NEWLINE .)
    END             reduce using rule 17 (statement -> assignment NEWLINE .)


state 41

    (18) statement -> while NEWLINE .

    RETURN          reduce using rule 18 (statement -> while NEWLINE .)
    error           reduce using rule 18 (statement -> while NEWLINE .)
    COMMENT         reduce using rule 18 (statement -> while NEWLINE .)
    DO              reduce using rule 18 (statement -> while NEWLINE .)
    IF              reduce using rule 18 (statement -> while NEWLINE .)
    FUNCTION        reduce using rule 18 (statement -> while NEWLINE .)
    VARIABLE        reduce using rule 18 (statement -> while NEWLINE .)
    INTEGER         reduce using rule 18 (statement -> while NEWLINE .)
    STRING          reduce using rule 18 (statement -> while NEWLINE .)
    BOOL            reduce using rule 18 (statement -> while NEWLINE .)
    VECTOR          reduce using rule 18 (statement -> while NEWLINE .)
    LEFT            reduce using rule 18 (statement -> while NEWLINE .)
    RIGHT           reduce using rule 18 (statement -> while NEWLINE .)
    FORWARD         reduce using rule 18 (statement -> while NEWLINE .)
    BACK            reduce using rule 18 (statement -> while NEWLINE .)
    ROTATE_RIGHT    reduce using rule 18 (statement -> while NEWLINE .)
    ROTATE_LEFT     reduce using rule 18 (statement -> while NEWLINE .)
    LMS             reduce using rule 18 (statement -> while NEWLINE .)
    REFLECT         reduce using rule 18 (statement -> while NEWLINE .)
    DRILL           reduce using rule 18 (statement -> while NEWLINE .)
    NEWLINE         reduce using rule 18 (statement -> while NEWLINE .)
    $end            reduce using rule 18 (statement -> while NEWLINE .)
    END             reduce using rule 18 (statement -> while NEWLINE .)


state 42

    (19) statement -> if NEWLINE .

    RETURN          reduce using rule 19 (statement -> if NEWLINE .)
    error           reduce using rule 19 (statement -> if NEWLINE .)
    COMMENT         reduce using rule 19 (statement -> if NEWLINE .)
    DO              reduce using rule 19 (statement -> if NEWLINE .)
    IF              reduce using rule 19 (statement -> if NEWLINE .)
    FUNCTION        reduce using rule 19 (statement -> if NEWLINE .)
    VARIABLE        reduce using rule 19 (statement -> if NEWLINE .)
    INTEGER         reduce using rule 19 (statement -> if NEWLINE .)
    STRING          reduce using rule 19 (statement -> if NEWLINE .)
    BOOL            reduce using rule 19 (statement -> if NEWLINE .)
    VECTOR          reduce using rule 19 (statement -> if NEWLINE .)
    LEFT            reduce using rule 19 (statement -> if NEWLINE .)
    RIGHT           reduce using rule 19 (statement -> if NEWLINE .)
    FORWARD         reduce using rule 19 (statement -> if NEWLINE .)
    BACK            reduce using rule 19 (statement -> if NEWLINE .)
    ROTATE_RIGHT    reduce using rule 19 (statement -> if NEWLINE .)
    ROTATE_LEFT     reduce using rule 19 (statement -> if NEWLINE .)
    LMS             reduce using rule 19 (statement -> if NEWLINE .)
    REFLECT         reduce using rule 19 (statement -> if NEWLINE .)
    DRILL           reduce using rule 19 (statement -> if NEWLINE .)
    NEWLINE         reduce using rule 19 (statement -> if NEWLINE .)
    $end            reduce using rule 19 (statement -> if NEWLINE .)
    END             reduce using rule 19 (statement -> if NEWLINE .)


state 43

    (20) statement -> command NEWLINE .

    RETURN          reduce using rule 20 (statement -> command NEWLINE .)
    error           reduce using rule 20 (statement -> command NEWLINE .)
    COMMENT         reduce using rule 20 (statement -> command NEWLINE .)
    DO              reduce using rule 20 (statement -> command NEWLINE .)
    IF              reduce using rule 20 (statement -> command NEWLINE .)
    FUNCTION        reduce using rule 20 (statement -> command NEWLINE .)
    VARIABLE        reduce using rule 20 (statement -> command NEWLINE .)
    INTEGER         reduce using rule 20 (statement -> command NEWLINE .)
    STRING          reduce using rule 20 (statement -> command NEWLINE .)
    BOOL            reduce using rule 20 (statement -> command NEWLINE .)
    VECTOR          reduce using rule 20 (statement -> command NEWLINE .)
    LEFT            reduce using rule 20 (statement -> command NEWLINE .)
    RIGHT           reduce using rule 20 (statement -> command NEWLINE .)
    FORWARD         reduce using rule 20 (statement -> command NEWLINE .)
    BACK            reduce using rule 20 (statement -> command NEWLINE .)
    ROTATE_RIGHT    reduce using rule 20 (statement -> command NEWLINE .)
    ROTATE_LEFT     reduce using rule 20 (statement -> command NEWLINE .)
    LMS             reduce using rule 20 (statement -> command NEWLINE .)
    REFLECT         reduce using rule 20 (statement -> command NEWLINE .)
    DRILL           reduce using rule 20 (statement -> command NEWLINE .)
    NEWLINE         reduce using rule 20 (statement -> command NEWLINE .)
    $end            reduce using rule 20 (statement -> command NEWLINE .)
    END             reduce using rule 20 (statement -> command NEWLINE .)


state 44

    (21) statement -> function NEWLINE .

    RETURN          reduce using rule 21 (statement -> function NEWLINE .)
    error           reduce using rule 21 (statement -> function NEWLINE .)
    COMMENT         reduce using rule 21 (statement -> function NEWLINE .)
    DO              reduce using rule 21 (statement -> function NEWLINE .)
    IF              reduce using rule 21 (statement -> function NEWLINE .)
    FUNCTION        reduce using rule 21 (statement -> function NEWLINE .)
    VARIABLE        reduce using rule 21 (statement -> function NEWLINE .)
    INTEGER         reduce using rule 21 (statement -> function NEWLINE .)
    STRING          reduce using rule 21 (statement -> function NEWLINE .)
    BOOL            reduce using rule 21 (statement -> function NEWLINE .)
    VECTOR          reduce using rule 21 (statement -> function NEWLINE .)
    LEFT            reduce using rule 21 (statement -> function NEWLINE .)
    RIGHT           reduce using rule 21 (statement -> function NEWLINE .)
    FORWARD         reduce using rule 21 (statement -> function NEWLINE .)
    BACK            reduce using rule 21 (statement -> function NEWLINE .)
    ROTATE_RIGHT    reduce using rule 21 (statement -> function NEWLINE .)
    ROTATE_LEFT     reduce using rule 21 (statement -> function NEWLINE .)
    LMS             reduce using rule 21 (statement -> function NEWLINE .)
    REFLECT         reduce using rule 21 (statement -> function NEWLINE .)
    DRILL           reduce using rule 21 (statement -> function NEWLINE .)
    NEWLINE         reduce using rule 21 (statement -> function NEWLINE .)
    $end            reduce using rule 21 (statement -> function NEWLINE .)
    END             reduce using rule 21 (statement -> function NEWLINE .)


state 45

    (22) statement -> call NEWLINE .

    RETURN          reduce using rule 22 (statement -> call NEWLINE .)
    error           reduce using rule 22 (statement -> call NEWLINE .)
    COMMENT         reduce using rule 22 (statement -> call NEWLINE .)
    DO              reduce using rule 22 (statement -> call NEWLINE .)
    IF              reduce using rule 22 (statement -> call NEWLINE .)
    FUNCTION        reduce using rule 22 (statement -> call NEWLINE .)
    VARIABLE        reduce using rule 22 (statement -> call NEWLINE .)
    INTEGER         reduce using rule 22 (statement -> call NEWLINE .)
    STRING          reduce using rule 22 (statement -> call NEWLINE .)
    BOOL            reduce using rule 22 (statement -> call NEWLINE .)
    VECTOR          reduce using rule 22 (statement -> call NEWLINE .)
    LEFT            reduce using rule 22 (statement -> call NEWLINE .)
    RIGHT           reduce using rule 22 (statement -> call NEWLINE .)
    FORWARD         reduce using rule 22 (statement -> call NEWLINE .)
    BACK            reduce using rule 22 (statement -> call NEWLINE .)
    ROTATE_RIGHT    reduce using rule 22 (statement -> call NEWLINE .)
    ROTATE_LEFT     reduce using rule 22 (statement -> call NEWLINE .)
    LMS             reduce using rule 22 (statement -> call NEWLINE .)
    REFLECT         reduce using rule 22 (statement -> call NEWLINE .)
    DRILL           reduce using rule 22 (statement -> call NEWLINE .)
    NEWLINE         reduce using rule 22 (statement -> call NEWLINE .)
    $end            reduce using rule 22 (statement -> call NEWLINE .)
    END             reduce using rule 22 (statement -> call NEWLINE .)


state 46

    (23) statement -> RETURN expression . NEWLINE
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    NEWLINE         shift and go to state 102
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109


state 47

    (46) expression -> variable .
    (103) vector_pop -> variable . POP BACK
    (104) vector_pop -> variable . POP FRONT

    NEWLINE         reduce using rule 46 (expression -> variable .)
    LESS            reduce using rule 46 (expression -> variable .)
    GREATER         reduce using rule 46 (expression -> variable .)
    EQ              reduce using rule 46 (expression -> variable .)
    NOTEQ           reduce using rule 46 (expression -> variable .)
    PLUS            reduce using rule 46 (expression -> variable .)
    MINUS           reduce using rule 46 (expression -> variable .)
    TO              reduce using rule 46 (expression -> variable .)
    THEN            reduce using rule 46 (expression -> variable .)
    UNTIL           reduce using rule 46 (expression -> variable .)
    ELSE            reduce using rule 46 (expression -> variable .)
    RBRACKET        reduce using rule 46 (expression -> variable .)
    COMMA           reduce using rule 46 (expression -> variable .)
    R_QBRACKET      reduce using rule 46 (expression -> variable .)
    error           reduce using rule 46 (expression -> variable .)
    CONTINUE        reduce using rule 46 (expression -> variable .)
    POP             shift and go to state 110


state 48

    (47) expression -> const .

    NEWLINE         reduce using rule 47 (expression -> const .)
    LESS            reduce using rule 47 (expression -> const .)
    GREATER         reduce using rule 47 (expression -> const .)
    EQ              reduce using rule 47 (expression -> const .)
    NOTEQ           reduce using rule 47 (expression -> const .)
    PLUS            reduce using rule 47 (expression -> const .)
    MINUS           reduce using rule 47 (expression -> const .)
    TO              reduce using rule 47 (expression -> const .)
    THEN            reduce using rule 47 (expression -> const .)
    COMMA           reduce using rule 47 (expression -> const .)
    UNTIL           reduce using rule 47 (expression -> const .)
    ELSE            reduce using rule 47 (expression -> const .)
    RBRACKET        reduce using rule 47 (expression -> const .)
    R_QBRACKET      reduce using rule 47 (expression -> const .)
    error           reduce using rule 47 (expression -> const .)
    CONTINUE        reduce using rule 47 (expression -> const .)


state 49

    (48) expression -> qstring .

    NEWLINE         reduce using rule 48 (expression -> qstring .)
    LESS            reduce using rule 48 (expression -> qstring .)
    GREATER         reduce using rule 48 (expression -> qstring .)
    EQ              reduce using rule 48 (expression -> qstring .)
    NOTEQ           reduce using rule 48 (expression -> qstring .)
    PLUS            reduce using rule 48 (expression -> qstring .)
    MINUS           reduce using rule 48 (expression -> qstring .)
    TO              reduce using rule 48 (expression -> qstring .)
    THEN            reduce using rule 48 (expression -> qstring .)
    COMMA           reduce using rule 48 (expression -> qstring .)
    UNTIL           reduce using rule 48 (expression -> qstring .)
    ELSE            reduce using rule 48 (expression -> qstring .)
    RBRACKET        reduce using rule 48 (expression -> qstring .)
    R_QBRACKET      reduce using rule 48 (expression -> qstring .)
    error           reduce using rule 48 (expression -> qstring .)
    CONTINUE        reduce using rule 48 (expression -> qstring .)


state 50

    (49) expression -> math_expression .

    NEWLINE         reduce using rule 49 (expression -> math_expression .)
    LESS            reduce using rule 49 (expression -> math_expression .)
    GREATER         reduce using rule 49 (expression -> math_expression .)
    EQ              reduce using rule 49 (expression -> math_expression .)
    NOTEQ           reduce using rule 49 (expression -> math_expression .)
    PLUS            reduce using rule 49 (expression -> math_expression .)
    MINUS           reduce using rule 49 (expression -> math_expression .)
    TO              reduce using rule 49 (expression -> math_expression .)
    THEN            reduce using rule 49 (expression -> math_expression .)
    COMMA           reduce using rule 49 (expression -> math_expression .)
    UNTIL           reduce using rule 49 (expression -> math_expression .)
    ELSE            reduce using rule 49 (expression -> math_expression .)
    RBRACKET        reduce using rule 49 (expression -> math_expression .)
    R_QBRACKET      reduce using rule 49 (expression -> math_expression .)
    error           reduce using rule 49 (expression -> math_expression .)
    CONTINUE        reduce using rule 49 (expression -> math_expression .)


state 51

    (50) expression -> robot_command .

    NEWLINE         reduce using rule 50 (expression -> robot_command .)
    LESS            reduce using rule 50 (expression -> robot_command .)
    GREATER         reduce using rule 50 (expression -> robot_command .)
    EQ              reduce using rule 50 (expression -> robot_command .)
    NOTEQ           reduce using rule 50 (expression -> robot_command .)
    PLUS            reduce using rule 50 (expression -> robot_command .)
    MINUS           reduce using rule 50 (expression -> robot_command .)
    TO              reduce using rule 50 (expression -> robot_command .)
    THEN            reduce using rule 50 (expression -> robot_command .)
    COMMA           reduce using rule 50 (expression -> robot_command .)
    UNTIL           reduce using rule 50 (expression -> robot_command .)
    ELSE            reduce using rule 50 (expression -> robot_command .)
    RBRACKET        reduce using rule 50 (expression -> robot_command .)
    R_QBRACKET      reduce using rule 50 (expression -> robot_command .)
    error           reduce using rule 50 (expression -> robot_command .)
    CONTINUE        reduce using rule 50 (expression -> robot_command .)


state 52

    (51) expression -> converting_command .

    NEWLINE         reduce using rule 51 (expression -> converting_command .)
    LESS            reduce using rule 51 (expression -> converting_command .)
    GREATER         reduce using rule 51 (expression -> converting_command .)
    EQ              reduce using rule 51 (expression -> converting_command .)
    NOTEQ           reduce using rule 51 (expression -> converting_command .)
    PLUS            reduce using rule 51 (expression -> converting_command .)
    MINUS           reduce using rule 51 (expression -> converting_command .)
    TO              reduce using rule 51 (expression -> converting_command .)
    THEN            reduce using rule 51 (expression -> converting_command .)
    COMMA           reduce using rule 51 (expression -> converting_command .)
    UNTIL           reduce using rule 51 (expression -> converting_command .)
    ELSE            reduce using rule 51 (expression -> converting_command .)
    RBRACKET        reduce using rule 51 (expression -> converting_command .)
    R_QBRACKET      reduce using rule 51 (expression -> converting_command .)
    error           reduce using rule 51 (expression -> converting_command .)
    CONTINUE        reduce using rule 51 (expression -> converting_command .)


state 53

    (52) expression -> vector_pop .

    NEWLINE         reduce using rule 52 (expression -> vector_pop .)
    LESS            reduce using rule 52 (expression -> vector_pop .)
    GREATER         reduce using rule 52 (expression -> vector_pop .)
    EQ              reduce using rule 52 (expression -> vector_pop .)
    NOTEQ           reduce using rule 52 (expression -> vector_pop .)
    PLUS            reduce using rule 52 (expression -> vector_pop .)
    MINUS           reduce using rule 52 (expression -> vector_pop .)
    TO              reduce using rule 52 (expression -> vector_pop .)
    THEN            reduce using rule 52 (expression -> vector_pop .)
    COMMA           reduce using rule 52 (expression -> vector_pop .)
    UNTIL           reduce using rule 52 (expression -> vector_pop .)
    ELSE            reduce using rule 52 (expression -> vector_pop .)
    RBRACKET        reduce using rule 52 (expression -> vector_pop .)
    R_QBRACKET      reduce using rule 52 (expression -> vector_pop .)
    error           reduce using rule 52 (expression -> vector_pop .)
    CONTINUE        reduce using rule 52 (expression -> vector_pop .)


state 54

    (53) expression -> call .

    NEWLINE         reduce using rule 53 (expression -> call .)
    LESS            reduce using rule 53 (expression -> call .)
    GREATER         reduce using rule 53 (expression -> call .)
    EQ              reduce using rule 53 (expression -> call .)
    NOTEQ           reduce using rule 53 (expression -> call .)
    PLUS            reduce using rule 53 (expression -> call .)
    MINUS           reduce using rule 53 (expression -> call .)
    TO              reduce using rule 53 (expression -> call .)
    THEN            reduce using rule 53 (expression -> call .)
    COMMA           reduce using rule 53 (expression -> call .)
    UNTIL           reduce using rule 53 (expression -> call .)
    ELSE            reduce using rule 53 (expression -> call .)
    RBRACKET        reduce using rule 53 (expression -> call .)
    R_QBRACKET      reduce using rule 53 (expression -> call .)
    error           reduce using rule 53 (expression -> call .)
    CONTINUE        reduce using rule 53 (expression -> call .)


state 55

    (42) variable -> VARIABLE . indexing
    (43) variable -> VARIABLE .
    (114) call -> VARIABLE . LBRACKET parameters RBRACKET
    (115) call -> VARIABLE . BRACKETS
    (116) call -> VARIABLE . LBRACKET error RBRACKET
    (44) indexing -> . L_QBRACKET expression R_QBRACKET indexing
    (45) indexing -> . L_QBRACKET expression R_QBRACKET

    POP             reduce using rule 43 (variable -> VARIABLE .)
    NEWLINE         reduce using rule 43 (variable -> VARIABLE .)
    LESS            reduce using rule 43 (variable -> VARIABLE .)
    GREATER         reduce using rule 43 (variable -> VARIABLE .)
    EQ              reduce using rule 43 (variable -> VARIABLE .)
    NOTEQ           reduce using rule 43 (variable -> VARIABLE .)
    PLUS            reduce using rule 43 (variable -> VARIABLE .)
    MINUS           reduce using rule 43 (variable -> VARIABLE .)
    TO              reduce using rule 43 (variable -> VARIABLE .)
    THEN            reduce using rule 43 (variable -> VARIABLE .)
    ASSIGNMENT      reduce using rule 43 (variable -> VARIABLE .)
    COMMA           reduce using rule 43 (variable -> VARIABLE .)
    UNTIL           reduce using rule 43 (variable -> VARIABLE .)
    ELSE            reduce using rule 43 (variable -> VARIABLE .)
    R_QBRACKET      reduce using rule 43 (variable -> VARIABLE .)
    RBRACKET        reduce using rule 43 (variable -> VARIABLE .)
    error           reduce using rule 43 (variable -> VARIABLE .)
    CONTINUE        reduce using rule 43 (variable -> VARIABLE .)
    LBRACKET        shift and go to state 97
    BRACKETS        shift and go to state 98
    L_QBRACKET      shift and go to state 100

    indexing                       shift and go to state 99

state 56

    (64) const -> TRUE .

    NEWLINE         reduce using rule 64 (const -> TRUE .)
    LESS            reduce using rule 64 (const -> TRUE .)
    GREATER         reduce using rule 64 (const -> TRUE .)
    EQ              reduce using rule 64 (const -> TRUE .)
    NOTEQ           reduce using rule 64 (const -> TRUE .)
    PLUS            reduce using rule 64 (const -> TRUE .)
    MINUS           reduce using rule 64 (const -> TRUE .)
    TO              reduce using rule 64 (const -> TRUE .)
    THEN            reduce using rule 64 (const -> TRUE .)
    COMMA           reduce using rule 64 (const -> TRUE .)
    UNTIL           reduce using rule 64 (const -> TRUE .)
    ELSE            reduce using rule 64 (const -> TRUE .)
    RBRACKET        reduce using rule 64 (const -> TRUE .)
    R_QBRACKET      reduce using rule 64 (const -> TRUE .)
    error           reduce using rule 64 (const -> TRUE .)
    CONTINUE        reduce using rule 64 (const -> TRUE .)


state 57

    (65) const -> FALSE .

    NEWLINE         reduce using rule 65 (const -> FALSE .)
    LESS            reduce using rule 65 (const -> FALSE .)
    GREATER         reduce using rule 65 (const -> FALSE .)
    EQ              reduce using rule 65 (const -> FALSE .)
    NOTEQ           reduce using rule 65 (const -> FALSE .)
    PLUS            reduce using rule 65 (const -> FALSE .)
    MINUS           reduce using rule 65 (const -> FALSE .)
    TO              reduce using rule 65 (const -> FALSE .)
    THEN            reduce using rule 65 (const -> FALSE .)
    COMMA           reduce using rule 65 (const -> FALSE .)
    UNTIL           reduce using rule 65 (const -> FALSE .)
    ELSE            reduce using rule 65 (const -> FALSE .)
    RBRACKET        reduce using rule 65 (const -> FALSE .)
    R_QBRACKET      reduce using rule 65 (const -> FALSE .)
    error           reduce using rule 65 (const -> FALSE .)
    CONTINUE        reduce using rule 65 (const -> FALSE .)


state 58

    (66) const -> UNDEFINED .

    NEWLINE         reduce using rule 66 (const -> UNDEFINED .)
    LESS            reduce using rule 66 (const -> UNDEFINED .)
    GREATER         reduce using rule 66 (const -> UNDEFINED .)
    EQ              reduce using rule 66 (const -> UNDEFINED .)
    NOTEQ           reduce using rule 66 (const -> UNDEFINED .)
    PLUS            reduce using rule 66 (const -> UNDEFINED .)
    MINUS           reduce using rule 66 (const -> UNDEFINED .)
    TO              reduce using rule 66 (const -> UNDEFINED .)
    THEN            reduce using rule 66 (const -> UNDEFINED .)
    COMMA           reduce using rule 66 (const -> UNDEFINED .)
    UNTIL           reduce using rule 66 (const -> UNDEFINED .)
    ELSE            reduce using rule 66 (const -> UNDEFINED .)
    RBRACKET        reduce using rule 66 (const -> UNDEFINED .)
    R_QBRACKET      reduce using rule 66 (const -> UNDEFINED .)
    error           reduce using rule 66 (const -> UNDEFINED .)
    CONTINUE        reduce using rule 66 (const -> UNDEFINED .)


state 59

    (67) const -> DECIMAL .

    NEWLINE         reduce using rule 67 (const -> DECIMAL .)
    LESS            reduce using rule 67 (const -> DECIMAL .)
    GREATER         reduce using rule 67 (const -> DECIMAL .)
    EQ              reduce using rule 67 (const -> DECIMAL .)
    NOTEQ           reduce using rule 67 (const -> DECIMAL .)
    PLUS            reduce using rule 67 (const -> DECIMAL .)
    MINUS           reduce using rule 67 (const -> DECIMAL .)
    TO              reduce using rule 67 (const -> DECIMAL .)
    THEN            reduce using rule 67 (const -> DECIMAL .)
    COMMA           reduce using rule 67 (const -> DECIMAL .)
    UNTIL           reduce using rule 67 (const -> DECIMAL .)
    ELSE            reduce using rule 67 (const -> DECIMAL .)
    RBRACKET        reduce using rule 67 (const -> DECIMAL .)
    R_QBRACKET      reduce using rule 67 (const -> DECIMAL .)
    error           reduce using rule 67 (const -> DECIMAL .)
    CONTINUE        reduce using rule 67 (const -> DECIMAL .)


state 60

    (68) const -> EXIT .

    NEWLINE         reduce using rule 68 (const -> EXIT .)
    LESS            reduce using rule 68 (const -> EXIT .)
    GREATER         reduce using rule 68 (const -> EXIT .)
    EQ              reduce using rule 68 (const -> EXIT .)
    NOTEQ           reduce using rule 68 (const -> EXIT .)
    PLUS            reduce using rule 68 (const -> EXIT .)
    MINUS           reduce using rule 68 (const -> EXIT .)
    TO              reduce using rule 68 (const -> EXIT .)
    THEN            reduce using rule 68 (const -> EXIT .)
    COMMA           reduce using rule 68 (const -> EXIT .)
    UNTIL           reduce using rule 68 (const -> EXIT .)
    ELSE            reduce using rule 68 (const -> EXIT .)
    RBRACKET        reduce using rule 68 (const -> EXIT .)
    R_QBRACKET      reduce using rule 68 (const -> EXIT .)
    error           reduce using rule 68 (const -> EXIT .)
    CONTINUE        reduce using rule 68 (const -> EXIT .)


state 61

    (69) const -> WOOD .

    NEWLINE         reduce using rule 69 (const -> WOOD .)
    LESS            reduce using rule 69 (const -> WOOD .)
    GREATER         reduce using rule 69 (const -> WOOD .)
    EQ              reduce using rule 69 (const -> WOOD .)
    NOTEQ           reduce using rule 69 (const -> WOOD .)
    PLUS            reduce using rule 69 (const -> WOOD .)
    MINUS           reduce using rule 69 (const -> WOOD .)
    TO              reduce using rule 69 (const -> WOOD .)
    THEN            reduce using rule 69 (const -> WOOD .)
    COMMA           reduce using rule 69 (const -> WOOD .)
    UNTIL           reduce using rule 69 (const -> WOOD .)
    ELSE            reduce using rule 69 (const -> WOOD .)
    RBRACKET        reduce using rule 69 (const -> WOOD .)
    R_QBRACKET      reduce using rule 69 (const -> WOOD .)
    error           reduce using rule 69 (const -> WOOD .)
    CONTINUE        reduce using rule 69 (const -> WOOD .)


state 62

    (70) const -> STEEL .

    NEWLINE         reduce using rule 70 (const -> STEEL .)
    LESS            reduce using rule 70 (const -> STEEL .)
    GREATER         reduce using rule 70 (const -> STEEL .)
    EQ              reduce using rule 70 (const -> STEEL .)
    NOTEQ           reduce using rule 70 (const -> STEEL .)
    PLUS            reduce using rule 70 (const -> STEEL .)
    MINUS           reduce using rule 70 (const -> STEEL .)
    TO              reduce using rule 70 (const -> STEEL .)
    THEN            reduce using rule 70 (const -> STEEL .)
    COMMA           reduce using rule 70 (const -> STEEL .)
    UNTIL           reduce using rule 70 (const -> STEEL .)
    ELSE            reduce using rule 70 (const -> STEEL .)
    RBRACKET        reduce using rule 70 (const -> STEEL .)
    R_QBRACKET      reduce using rule 70 (const -> STEEL .)
    error           reduce using rule 70 (const -> STEEL .)
    CONTINUE        reduce using rule 70 (const -> STEEL .)


state 63

    (71) const -> GLASS .

    NEWLINE         reduce using rule 71 (const -> GLASS .)
    LESS            reduce using rule 71 (const -> GLASS .)
    GREATER         reduce using rule 71 (const -> GLASS .)
    EQ              reduce using rule 71 (const -> GLASS .)
    NOTEQ           reduce using rule 71 (const -> GLASS .)
    PLUS            reduce using rule 71 (const -> GLASS .)
    MINUS           reduce using rule 71 (const -> GLASS .)
    TO              reduce using rule 71 (const -> GLASS .)
    THEN            reduce using rule 71 (const -> GLASS .)
    COMMA           reduce using rule 71 (const -> GLASS .)
    UNTIL           reduce using rule 71 (const -> GLASS .)
    ELSE            reduce using rule 71 (const -> GLASS .)
    RBRACKET        reduce using rule 71 (const -> GLASS .)
    R_QBRACKET      reduce using rule 71 (const -> GLASS .)
    error           reduce using rule 71 (const -> GLASS .)
    CONTINUE        reduce using rule 71 (const -> GLASS .)


state 64

    (72) const -> CONCRETE .

    NEWLINE         reduce using rule 72 (const -> CONCRETE .)
    LESS            reduce using rule 72 (const -> CONCRETE .)
    GREATER         reduce using rule 72 (const -> CONCRETE .)
    EQ              reduce using rule 72 (const -> CONCRETE .)
    NOTEQ           reduce using rule 72 (const -> CONCRETE .)
    PLUS            reduce using rule 72 (const -> CONCRETE .)
    MINUS           reduce using rule 72 (const -> CONCRETE .)
    TO              reduce using rule 72 (const -> CONCRETE .)
    THEN            reduce using rule 72 (const -> CONCRETE .)
    COMMA           reduce using rule 72 (const -> CONCRETE .)
    UNTIL           reduce using rule 72 (const -> CONCRETE .)
    ELSE            reduce using rule 72 (const -> CONCRETE .)
    RBRACKET        reduce using rule 72 (const -> CONCRETE .)
    R_QBRACKET      reduce using rule 72 (const -> CONCRETE .)
    error           reduce using rule 72 (const -> CONCRETE .)
    CONTINUE        reduce using rule 72 (const -> CONCRETE .)


state 65

    (73) const -> PLASTIC .

    NEWLINE         reduce using rule 73 (const -> PLASTIC .)
    LESS            reduce using rule 73 (const -> PLASTIC .)
    GREATER         reduce using rule 73 (const -> PLASTIC .)
    EQ              reduce using rule 73 (const -> PLASTIC .)
    NOTEQ           reduce using rule 73 (const -> PLASTIC .)
    PLUS            reduce using rule 73 (const -> PLASTIC .)
    MINUS           reduce using rule 73 (const -> PLASTIC .)
    TO              reduce using rule 73 (const -> PLASTIC .)
    THEN            reduce using rule 73 (const -> PLASTIC .)
    COMMA           reduce using rule 73 (const -> PLASTIC .)
    UNTIL           reduce using rule 73 (const -> PLASTIC .)
    ELSE            reduce using rule 73 (const -> PLASTIC .)
    RBRACKET        reduce using rule 73 (const -> PLASTIC .)
    R_QBRACKET      reduce using rule 73 (const -> PLASTIC .)
    error           reduce using rule 73 (const -> PLASTIC .)
    CONTINUE        reduce using rule 73 (const -> PLASTIC .)


state 66

    (54) qstring -> DOUBLE_QUOTE . string DOUBLE_QUOTE
    (56) string -> . VARIABLE string
    (57) string -> . DECIMAL string
    (58) string -> . FALSE string
    (59) string -> . TRUE string
    (60) string -> . FALSE
    (61) string -> . TRUE
    (62) string -> . DECIMAL
    (63) string -> . VARIABLE

    VARIABLE        shift and go to state 112
    DECIMAL         shift and go to state 113
    FALSE           shift and go to state 114
    TRUE            shift and go to state 115

    string                         shift and go to state 111

state 67

    (55) qstring -> QUOTE . string QUOTE
    (56) string -> . VARIABLE string
    (57) string -> . DECIMAL string
    (58) string -> . FALSE string
    (59) string -> . TRUE string
    (60) string -> . FALSE
    (61) string -> . TRUE
    (62) string -> . DECIMAL
    (63) string -> . VARIABLE

    VARIABLE        shift and go to state 112
    DECIMAL         shift and go to state 113
    FALSE           shift and go to state 114
    TRUE            shift and go to state 115

    string                         shift and go to state 116

state 68

    (24) statement -> empty NEWLINE .

    RETURN          reduce using rule 24 (statement -> empty NEWLINE .)
    error           reduce using rule 24 (statement -> empty NEWLINE .)
    COMMENT         reduce using rule 24 (statement -> empty NEWLINE .)
    DO              reduce using rule 24 (statement -> empty NEWLINE .)
    IF              reduce using rule 24 (statement -> empty NEWLINE .)
    FUNCTION        reduce using rule 24 (statement -> empty NEWLINE .)
    VARIABLE        reduce using rule 24 (statement -> empty NEWLINE .)
    INTEGER         reduce using rule 24 (statement -> empty NEWLINE .)
    STRING          reduce using rule 24 (statement -> empty NEWLINE .)
    BOOL            reduce using rule 24 (statement -> empty NEWLINE .)
    VECTOR          reduce using rule 24 (statement -> empty NEWLINE .)
    LEFT            reduce using rule 24 (statement -> empty NEWLINE .)
    RIGHT           reduce using rule 24 (statement -> empty NEWLINE .)
    FORWARD         reduce using rule 24 (statement -> empty NEWLINE .)
    BACK            reduce using rule 24 (statement -> empty NEWLINE .)
    ROTATE_RIGHT    reduce using rule 24 (statement -> empty NEWLINE .)
    ROTATE_LEFT     reduce using rule 24 (statement -> empty NEWLINE .)
    LMS             reduce using rule 24 (statement -> empty NEWLINE .)
    REFLECT         reduce using rule 24 (statement -> empty NEWLINE .)
    DRILL           reduce using rule 24 (statement -> empty NEWLINE .)
    NEWLINE         reduce using rule 24 (statement -> empty NEWLINE .)
    $end            reduce using rule 24 (statement -> empty NEWLINE .)
    END             reduce using rule 24 (statement -> empty NEWLINE .)


state 69

    (26) declaration -> type variables .

    NEWLINE         reduce using rule 26 (declaration -> type variables .)
    UNTIL           reduce using rule 26 (declaration -> type variables .)
    ELSE            reduce using rule 26 (declaration -> type variables .)


state 70

    (27) declaration -> type error .

    NEWLINE         reduce using rule 27 (declaration -> type error .)
    UNTIL           reduce using rule 27 (declaration -> type error .)
    ELSE            reduce using rule 27 (declaration -> type error .)


state 71

    (35) variables -> variable . COMMA variables
    (37) variables -> variable .
    (39) assignment -> variable . ASSIGNMENT expression
    (40) assignment -> variable . ASSIGNMENT assignment
    (41) assignment -> variable . ASSIGNMENT error

    COMMA           shift and go to state 117
    NEWLINE         reduce using rule 37 (variables -> variable .)
    UNTIL           reduce using rule 37 (variables -> variable .)
    ELSE            reduce using rule 37 (variables -> variable .)
    ASSIGNMENT      shift and go to state 76


state 72

    (36) variables -> assignment . COMMA variables
    (38) variables -> assignment .

    COMMA           shift and go to state 118
    NEWLINE         reduce using rule 38 (variables -> assignment .)
    UNTIL           reduce using rule 38 (variables -> assignment .)
    ELSE            reduce using rule 38 (variables -> assignment .)


state 73

    (42) variable -> VARIABLE . indexing
    (43) variable -> VARIABLE .
    (44) indexing -> . L_QBRACKET expression R_QBRACKET indexing
    (45) indexing -> . L_QBRACKET expression R_QBRACKET

    COMMA           reduce using rule 43 (variable -> VARIABLE .)
    ASSIGNMENT      reduce using rule 43 (variable -> VARIABLE .)
    NEWLINE         reduce using rule 43 (variable -> VARIABLE .)
    UNTIL           reduce using rule 43 (variable -> VARIABLE .)
    ELSE            reduce using rule 43 (variable -> VARIABLE .)
    L_QBRACKET      shift and go to state 100

    indexing                       shift and go to state 99

state 74

    (28) comment -> COMMENT any .
    (29) any -> any . VARIABLE

    NEWLINE         reduce using rule 28 (comment -> COMMENT any .)
    VARIABLE        shift and go to state 119


state 75

    (30) any -> VARIABLE .

    VARIABLE        reduce using rule 30 (any -> VARIABLE .)
    NEWLINE         reduce using rule 30 (any -> VARIABLE .)


state 76

    (39) assignment -> variable ASSIGNMENT . expression
    (40) assignment -> variable ASSIGNMENT . assignment
    (41) assignment -> variable ASSIGNMENT . error
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    error           shift and go to state 123
    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    variable                       shift and go to state 120
    expression                     shift and go to state 121
    assignment                     shift and go to state 122
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 77

    (99) vector_command -> variable PUSH . BACK expression
    (100) vector_command -> variable PUSH . FRONT expression
    (101) vector_command -> variable PUSH . BACK error
    (102) vector_command -> variable PUSH . FRONT error

    BACK            shift and go to state 124
    FRONT           shift and go to state 125


state 78

    (80) while -> DO statements_group . UNTIL expression

    UNTIL           shift and go to state 126


state 79

    (81) while -> DO error .

    NEWLINE         reduce using rule 81 (while -> DO error .)
    UNTIL           reduce using rule 81 (while -> DO error .)
    ELSE            reduce using rule 81 (while -> DO error .)


state 80

    (2) statements_group -> BEGIN . statements END
    (13) statements -> . statements statement
    (14) statements -> . statement
    (15) statement -> . declaration NEWLINE
    (16) statement -> . comment NEWLINE
    (17) statement -> . assignment NEWLINE
    (18) statement -> . while NEWLINE
    (19) statement -> . if NEWLINE
    (20) statement -> . command NEWLINE
    (21) statement -> . function NEWLINE
    (22) statement -> . call NEWLINE
    (23) statement -> . RETURN expression NEWLINE
    (24) statement -> . empty NEWLINE
    (25) statement -> . error
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (28) comment -> . COMMENT any
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    RETURN          shift and go to state 12
    error           shift and go to state 14
    COMMENT         shift and go to state 16
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    NEWLINE         reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    statements                     shift and go to state 127
    statement                      shift and go to state 3
    declaration                    shift and go to state 4
    comment                        shift and go to state 5
    assignment                     shift and go to state 6
    while                          shift and go to state 7
    if                             shift and go to state 8
    command                        shift and go to state 9
    function                       shift and go to state 10
    call                           shift and go to state 11
    empty                          shift and go to state 13
    type                           shift and go to state 15
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 81

    (3) statements_group -> inner_statement .

    UNTIL           reduce using rule 3 (statements_group -> inner_statement .)
    ELSE            reduce using rule 3 (statements_group -> inner_statement .)
    NEWLINE         reduce using rule 3 (statements_group -> inner_statement .)


state 82

    (4) inner_statement -> declaration .

    UNTIL           reduce using rule 4 (inner_statement -> declaration .)
    ELSE            reduce using rule 4 (inner_statement -> declaration .)
    NEWLINE         reduce using rule 4 (inner_statement -> declaration .)


state 83

    (5) inner_statement -> assignment .

    UNTIL           reduce using rule 5 (inner_statement -> assignment .)
    ELSE            reduce using rule 5 (inner_statement -> assignment .)
    NEWLINE         reduce using rule 5 (inner_statement -> assignment .)


state 84

    (6) inner_statement -> while .

    UNTIL           reduce using rule 6 (inner_statement -> while .)
    ELSE            reduce using rule 6 (inner_statement -> while .)
    NEWLINE         reduce using rule 6 (inner_statement -> while .)


state 85

    (7) inner_statement -> if .

    UNTIL           reduce using rule 7 (inner_statement -> if .)
    ELSE            reduce using rule 7 (inner_statement -> if .)
    NEWLINE         reduce using rule 7 (inner_statement -> if .)


state 86

    (8) inner_statement -> command .

    UNTIL           reduce using rule 8 (inner_statement -> command .)
    ELSE            reduce using rule 8 (inner_statement -> command .)
    NEWLINE         reduce using rule 8 (inner_statement -> command .)


state 87

    (9) inner_statement -> function .

    UNTIL           reduce using rule 9 (inner_statement -> function .)
    ELSE            reduce using rule 9 (inner_statement -> function .)
    NEWLINE         reduce using rule 9 (inner_statement -> function .)


state 88

    (10) inner_statement -> call .

    UNTIL           reduce using rule 10 (inner_statement -> call .)
    ELSE            reduce using rule 10 (inner_statement -> call .)
    NEWLINE         reduce using rule 10 (inner_statement -> call .)


state 89

    (11) inner_statement -> RETURN . expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 128
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 90

    (12) inner_statement -> empty .

    UNTIL           reduce using rule 12 (inner_statement -> empty .)
    ELSE            reduce using rule 12 (inner_statement -> empty .)
    NEWLINE         reduce using rule 12 (inner_statement -> empty .)


state 91

    (82) if -> IF expression . THEN statements_group
    (83) if -> IF expression . THEN statements_group ELSE statements_group
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    THEN            shift and go to state 129
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109


state 92

    (84) if -> IF error .

    NEWLINE         reduce using rule 84 (if -> IF error .)
    UNTIL           reduce using rule 84 (if -> IF error .)
    ELSE            reduce using rule 84 (if -> IF error .)


state 93

    (92) command -> vector_command error .

    NEWLINE         reduce using rule 92 (command -> vector_command error .)
    UNTIL           reduce using rule 92 (command -> vector_command error .)
    ELSE            reduce using rule 92 (command -> vector_command error .)


state 94

    (93) command -> robot_command error .

    NEWLINE         reduce using rule 93 (command -> robot_command error .)
    UNTIL           reduce using rule 93 (command -> robot_command error .)
    ELSE            reduce using rule 93 (command -> robot_command error .)


state 95

    (85) function -> FUNCTION OF . type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> FUNCTION OF . type VARIABLE BRACKETS statements_group
    (87) function -> FUNCTION OF . type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> FUNCTION OF . type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type

    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27

    type                           shift and go to state 130

state 96

    (89) function -> FUNCTION error .

    NEWLINE         reduce using rule 89 (function -> FUNCTION error .)
    UNTIL           reduce using rule 89 (function -> FUNCTION error .)
    ELSE            reduce using rule 89 (function -> FUNCTION error .)


state 97

    (114) call -> VARIABLE LBRACKET . parameters RBRACKET
    (116) call -> VARIABLE LBRACKET . error RBRACKET
    (118) parameters -> . parameters COMMA parameter
    (119) parameters -> . parameter
    (120) parameter -> . expression
    (121) parameter -> . VARIABLE EQ expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    error           shift and go to state 133
    VARIABLE        shift and go to state 131
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    parameters                     shift and go to state 132
    parameter                      shift and go to state 134
    expression                     shift and go to state 135
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 98

    (115) call -> VARIABLE BRACKETS .

    NEWLINE         reduce using rule 115 (call -> VARIABLE BRACKETS .)
    LESS            reduce using rule 115 (call -> VARIABLE BRACKETS .)
    GREATER         reduce using rule 115 (call -> VARIABLE BRACKETS .)
    EQ              reduce using rule 115 (call -> VARIABLE BRACKETS .)
    NOTEQ           reduce using rule 115 (call -> VARIABLE BRACKETS .)
    PLUS            reduce using rule 115 (call -> VARIABLE BRACKETS .)
    MINUS           reduce using rule 115 (call -> VARIABLE BRACKETS .)
    TO              reduce using rule 115 (call -> VARIABLE BRACKETS .)
    UNTIL           reduce using rule 115 (call -> VARIABLE BRACKETS .)
    THEN            reduce using rule 115 (call -> VARIABLE BRACKETS .)
    COMMA           reduce using rule 115 (call -> VARIABLE BRACKETS .)
    ELSE            reduce using rule 115 (call -> VARIABLE BRACKETS .)
    RBRACKET        reduce using rule 115 (call -> VARIABLE BRACKETS .)
    R_QBRACKET      reduce using rule 115 (call -> VARIABLE BRACKETS .)
    error           reduce using rule 115 (call -> VARIABLE BRACKETS .)
    CONTINUE        reduce using rule 115 (call -> VARIABLE BRACKETS .)


state 99

    (42) variable -> VARIABLE indexing .

    ASSIGNMENT      reduce using rule 42 (variable -> VARIABLE indexing .)
    PUSH            reduce using rule 42 (variable -> VARIABLE indexing .)
    POP             reduce using rule 42 (variable -> VARIABLE indexing .)
    NEWLINE         reduce using rule 42 (variable -> VARIABLE indexing .)
    LESS            reduce using rule 42 (variable -> VARIABLE indexing .)
    GREATER         reduce using rule 42 (variable -> VARIABLE indexing .)
    EQ              reduce using rule 42 (variable -> VARIABLE indexing .)
    NOTEQ           reduce using rule 42 (variable -> VARIABLE indexing .)
    PLUS            reduce using rule 42 (variable -> VARIABLE indexing .)
    MINUS           reduce using rule 42 (variable -> VARIABLE indexing .)
    TO              reduce using rule 42 (variable -> VARIABLE indexing .)
    COMMA           reduce using rule 42 (variable -> VARIABLE indexing .)
    UNTIL           reduce using rule 42 (variable -> VARIABLE indexing .)
    ELSE            reduce using rule 42 (variable -> VARIABLE indexing .)
    THEN            reduce using rule 42 (variable -> VARIABLE indexing .)
    RBRACKET        reduce using rule 42 (variable -> VARIABLE indexing .)
    R_QBRACKET      reduce using rule 42 (variable -> VARIABLE indexing .)
    error           reduce using rule 42 (variable -> VARIABLE indexing .)
    CONTINUE        reduce using rule 42 (variable -> VARIABLE indexing .)


state 100

    (44) indexing -> L_QBRACKET . expression R_QBRACKET indexing
    (45) indexing -> L_QBRACKET . expression R_QBRACKET
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 136
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 101

    (34) type -> VECTOR OF . type
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type

    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27

    type                           shift and go to state 137

state 102

    (23) statement -> RETURN expression NEWLINE .

    RETURN          reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    error           reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    COMMENT         reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    DO              reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    IF              reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    FUNCTION        reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    VARIABLE        reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    INTEGER         reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    STRING          reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    BOOL            reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    VECTOR          reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    LEFT            reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    RIGHT           reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    FORWARD         reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    BACK            reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    ROTATE_RIGHT    reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    ROTATE_LEFT     reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    LMS             reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    REFLECT         reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    DRILL           reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    NEWLINE         reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    $end            reduce using rule 23 (statement -> RETURN expression NEWLINE .)
    END             reduce using rule 23 (statement -> RETURN expression NEWLINE .)


state 103

    (74) math_expression -> expression LESS . expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 138
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 104

    (75) math_expression -> expression GREATER . expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 139
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 105

    (76) math_expression -> expression EQ . expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 140
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 106

    (77) math_expression -> expression NOTEQ . expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 141
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 107

    (78) math_expression -> expression PLUS . expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 142
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 108

    (79) math_expression -> expression MINUS . expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 143
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 109

    (94) converting_command -> expression TO . type
    (95) converting_command -> expression TO . expression
    (96) converting_command -> expression TO . vector_of
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (97) vector_of -> . VECTOR OF vector_of
    (98) vector_of -> . VECTOR
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 147
    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 144
    type                           shift and go to state 145
    vector_of                      shift and go to state 146
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 110

    (103) vector_pop -> variable POP . BACK
    (104) vector_pop -> variable POP . FRONT

    BACK            shift and go to state 148
    FRONT           shift and go to state 149


state 111

    (54) qstring -> DOUBLE_QUOTE string . DOUBLE_QUOTE

    DOUBLE_QUOTE    shift and go to state 150


state 112

    (56) string -> VARIABLE . string
    (63) string -> VARIABLE .
    (56) string -> . VARIABLE string
    (57) string -> . DECIMAL string
    (58) string -> . FALSE string
    (59) string -> . TRUE string
    (60) string -> . FALSE
    (61) string -> . TRUE
    (62) string -> . DECIMAL
    (63) string -> . VARIABLE

    DOUBLE_QUOTE    reduce using rule 63 (string -> VARIABLE .)
    QUOTE           reduce using rule 63 (string -> VARIABLE .)
    VARIABLE        shift and go to state 112
    DECIMAL         shift and go to state 113
    FALSE           shift and go to state 114
    TRUE            shift and go to state 115

    string                         shift and go to state 151

state 113

    (57) string -> DECIMAL . string
    (62) string -> DECIMAL .
    (56) string -> . VARIABLE string
    (57) string -> . DECIMAL string
    (58) string -> . FALSE string
    (59) string -> . TRUE string
    (60) string -> . FALSE
    (61) string -> . TRUE
    (62) string -> . DECIMAL
    (63) string -> . VARIABLE

    DOUBLE_QUOTE    reduce using rule 62 (string -> DECIMAL .)
    QUOTE           reduce using rule 62 (string -> DECIMAL .)
    VARIABLE        shift and go to state 112
    DECIMAL         shift and go to state 113
    FALSE           shift and go to state 114
    TRUE            shift and go to state 115

    string                         shift and go to state 152

state 114

    (58) string -> FALSE . string
    (60) string -> FALSE .
    (56) string -> . VARIABLE string
    (57) string -> . DECIMAL string
    (58) string -> . FALSE string
    (59) string -> . TRUE string
    (60) string -> . FALSE
    (61) string -> . TRUE
    (62) string -> . DECIMAL
    (63) string -> . VARIABLE

    DOUBLE_QUOTE    reduce using rule 60 (string -> FALSE .)
    QUOTE           reduce using rule 60 (string -> FALSE .)
    VARIABLE        shift and go to state 112
    DECIMAL         shift and go to state 113
    FALSE           shift and go to state 114
    TRUE            shift and go to state 115

    string                         shift and go to state 153

state 115

    (59) string -> TRUE . string
    (61) string -> TRUE .
    (56) string -> . VARIABLE string
    (57) string -> . DECIMAL string
    (58) string -> . FALSE string
    (59) string -> . TRUE string
    (60) string -> . FALSE
    (61) string -> . TRUE
    (62) string -> . DECIMAL
    (63) string -> . VARIABLE

    DOUBLE_QUOTE    reduce using rule 61 (string -> TRUE .)
    QUOTE           reduce using rule 61 (string -> TRUE .)
    VARIABLE        shift and go to state 112
    DECIMAL         shift and go to state 113
    FALSE           shift and go to state 114
    TRUE            shift and go to state 115

    string                         shift and go to state 154

state 116

    (55) qstring -> QUOTE string . QUOTE

    QUOTE           shift and go to state 155


state 117

    (35) variables -> variable COMMA . variables
    (35) variables -> . variable COMMA variables
    (36) variables -> . assignment COMMA variables
    (37) variables -> . variable
    (38) variables -> . assignment
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error

    VARIABLE        shift and go to state 73

    variable                       shift and go to state 71
    variables                      shift and go to state 156
    assignment                     shift and go to state 72

state 118

    (36) variables -> assignment COMMA . variables
    (35) variables -> . variable COMMA variables
    (36) variables -> . assignment COMMA variables
    (37) variables -> . variable
    (38) variables -> . assignment
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error

    VARIABLE        shift and go to state 73

    assignment                     shift and go to state 72
    variables                      shift and go to state 157
    variable                       shift and go to state 71

state 119

    (29) any -> any VARIABLE .

    VARIABLE        reduce using rule 29 (any -> any VARIABLE .)
    NEWLINE         reduce using rule 29 (any -> any VARIABLE .)


state 120

    (46) expression -> variable .
    (39) assignment -> variable . ASSIGNMENT expression
    (40) assignment -> variable . ASSIGNMENT assignment
    (41) assignment -> variable . ASSIGNMENT error
    (103) vector_pop -> variable . POP BACK
    (104) vector_pop -> variable . POP FRONT

    LESS            reduce using rule 46 (expression -> variable .)
    GREATER         reduce using rule 46 (expression -> variable .)
    EQ              reduce using rule 46 (expression -> variable .)
    NOTEQ           reduce using rule 46 (expression -> variable .)
    PLUS            reduce using rule 46 (expression -> variable .)
    MINUS           reduce using rule 46 (expression -> variable .)
    TO              reduce using rule 46 (expression -> variable .)
    NEWLINE         reduce using rule 46 (expression -> variable .)
    COMMA           reduce using rule 46 (expression -> variable .)
    UNTIL           reduce using rule 46 (expression -> variable .)
    ELSE            reduce using rule 46 (expression -> variable .)
    ASSIGNMENT      shift and go to state 76
    POP             shift and go to state 110


state 121

    (39) assignment -> variable ASSIGNMENT expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    NEWLINE         reduce using rule 39 (assignment -> variable ASSIGNMENT expression .)
    COMMA           reduce using rule 39 (assignment -> variable ASSIGNMENT expression .)
    UNTIL           reduce using rule 39 (assignment -> variable ASSIGNMENT expression .)
    ELSE            reduce using rule 39 (assignment -> variable ASSIGNMENT expression .)
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109


state 122

    (40) assignment -> variable ASSIGNMENT assignment .

    NEWLINE         reduce using rule 40 (assignment -> variable ASSIGNMENT assignment .)
    COMMA           reduce using rule 40 (assignment -> variable ASSIGNMENT assignment .)
    UNTIL           reduce using rule 40 (assignment -> variable ASSIGNMENT assignment .)
    ELSE            reduce using rule 40 (assignment -> variable ASSIGNMENT assignment .)


state 123

    (41) assignment -> variable ASSIGNMENT error .

    NEWLINE         reduce using rule 41 (assignment -> variable ASSIGNMENT error .)
    COMMA           reduce using rule 41 (assignment -> variable ASSIGNMENT error .)
    UNTIL           reduce using rule 41 (assignment -> variable ASSIGNMENT error .)
    ELSE            reduce using rule 41 (assignment -> variable ASSIGNMENT error .)


state 124

    (99) vector_command -> variable PUSH BACK . expression
    (101) vector_command -> variable PUSH BACK . error
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    error           shift and go to state 159
    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    variable                       shift and go to state 47
    expression                     shift and go to state 158
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 125

    (100) vector_command -> variable PUSH FRONT . expression
    (102) vector_command -> variable PUSH FRONT . error
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    error           shift and go to state 161
    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    variable                       shift and go to state 47
    expression                     shift and go to state 160
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 126

    (80) while -> DO statements_group UNTIL . expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 162
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 127

    (2) statements_group -> BEGIN statements . END
    (13) statements -> statements . statement
    (15) statement -> . declaration NEWLINE
    (16) statement -> . comment NEWLINE
    (17) statement -> . assignment NEWLINE
    (18) statement -> . while NEWLINE
    (19) statement -> . if NEWLINE
    (20) statement -> . command NEWLINE
    (21) statement -> . function NEWLINE
    (22) statement -> . call NEWLINE
    (23) statement -> . RETURN expression NEWLINE
    (24) statement -> . empty NEWLINE
    (25) statement -> . error
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (28) comment -> . COMMENT any
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    END             shift and go to state 163
    RETURN          shift and go to state 12
    error           shift and go to state 14
    COMMENT         shift and go to state 16
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    NEWLINE         reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    statement                      shift and go to state 37
    declaration                    shift and go to state 4
    comment                        shift and go to state 5
    assignment                     shift and go to state 6
    while                          shift and go to state 7
    if                             shift and go to state 8
    command                        shift and go to state 9
    function                       shift and go to state 10
    call                           shift and go to state 11
    empty                          shift and go to state 13
    type                           shift and go to state 15
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 128

    (11) inner_statement -> RETURN expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    UNTIL           reduce using rule 11 (inner_statement -> RETURN expression .)
    ELSE            reduce using rule 11 (inner_statement -> RETURN expression .)
    NEWLINE         reduce using rule 11 (inner_statement -> RETURN expression .)
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109


state 129

    (82) if -> IF expression THEN . statements_group
    (83) if -> IF expression THEN . statements_group ELSE statements_group
    (2) statements_group -> . BEGIN statements END
    (3) statements_group -> . inner_statement
    (4) inner_statement -> . declaration
    (5) inner_statement -> . assignment
    (6) inner_statement -> . while
    (7) inner_statement -> . if
    (8) inner_statement -> . command
    (9) inner_statement -> . function
    (10) inner_statement -> . call
    (11) inner_statement -> . RETURN expression
    (12) inner_statement -> . empty
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    BEGIN           shift and go to state 80
    RETURN          shift and go to state 89
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    ELSE            reduce using rule 117 (empty -> .)
    NEWLINE         reduce using rule 117 (empty -> .)
    UNTIL           reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    statements_group               shift and go to state 164
    inner_statement                shift and go to state 81
    declaration                    shift and go to state 82
    assignment                     shift and go to state 83
    while                          shift and go to state 84
    if                             shift and go to state 85
    command                        shift and go to state 86
    function                       shift and go to state 87
    call                           shift and go to state 88
    empty                          shift and go to state 90
    type                           shift and go to state 15
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 130

    (85) function -> FUNCTION OF type . VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> FUNCTION OF type . VARIABLE BRACKETS statements_group
    (87) function -> FUNCTION OF type . VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> FUNCTION OF type . VARIABLE LBRACKET CONTINUE RBRACKET statements_group

    VARIABLE        shift and go to state 165


state 131

    (121) parameter -> VARIABLE . EQ expression
    (42) variable -> VARIABLE . indexing
    (43) variable -> VARIABLE .
    (114) call -> VARIABLE . LBRACKET parameters RBRACKET
    (115) call -> VARIABLE . BRACKETS
    (116) call -> VARIABLE . LBRACKET error RBRACKET
    (44) indexing -> . L_QBRACKET expression R_QBRACKET indexing
    (45) indexing -> . L_QBRACKET expression R_QBRACKET

  ! shift/reduce conflict for EQ resolved as shift
    EQ              shift and go to state 166
    POP             reduce using rule 43 (variable -> VARIABLE .)
    LESS            reduce using rule 43 (variable -> VARIABLE .)
    GREATER         reduce using rule 43 (variable -> VARIABLE .)
    NOTEQ           reduce using rule 43 (variable -> VARIABLE .)
    PLUS            reduce using rule 43 (variable -> VARIABLE .)
    MINUS           reduce using rule 43 (variable -> VARIABLE .)
    TO              reduce using rule 43 (variable -> VARIABLE .)
    RBRACKET        reduce using rule 43 (variable -> VARIABLE .)
    COMMA           reduce using rule 43 (variable -> VARIABLE .)
    CONTINUE        reduce using rule 43 (variable -> VARIABLE .)
    LBRACKET        shift and go to state 97
    BRACKETS        shift and go to state 98
    L_QBRACKET      shift and go to state 100

  ! EQ              [ reduce using rule 43 (variable -> VARIABLE .) ]

    indexing                       shift and go to state 99

state 132

    (114) call -> VARIABLE LBRACKET parameters . RBRACKET
    (118) parameters -> parameters . COMMA parameter

    RBRACKET        shift and go to state 167
    COMMA           shift and go to state 168


state 133

    (116) call -> VARIABLE LBRACKET error . RBRACKET

    RBRACKET        shift and go to state 169


state 134

    (119) parameters -> parameter .

    RBRACKET        reduce using rule 119 (parameters -> parameter .)
    COMMA           reduce using rule 119 (parameters -> parameter .)
    CONTINUE        reduce using rule 119 (parameters -> parameter .)


state 135

    (120) parameter -> expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    RBRACKET        reduce using rule 120 (parameter -> expression .)
    COMMA           reduce using rule 120 (parameter -> expression .)
    CONTINUE        reduce using rule 120 (parameter -> expression .)
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109


state 136

    (44) indexing -> L_QBRACKET expression . R_QBRACKET indexing
    (45) indexing -> L_QBRACKET expression . R_QBRACKET
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    R_QBRACKET      shift and go to state 170
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109


state 137

    (34) type -> VECTOR OF type .

    error           reduce using rule 34 (type -> VECTOR OF type .)
    VARIABLE        reduce using rule 34 (type -> VECTOR OF type .)
    NEWLINE         reduce using rule 34 (type -> VECTOR OF type .)
    LESS            reduce using rule 34 (type -> VECTOR OF type .)
    GREATER         reduce using rule 34 (type -> VECTOR OF type .)
    EQ              reduce using rule 34 (type -> VECTOR OF type .)
    NOTEQ           reduce using rule 34 (type -> VECTOR OF type .)
    PLUS            reduce using rule 34 (type -> VECTOR OF type .)
    MINUS           reduce using rule 34 (type -> VECTOR OF type .)
    TO              reduce using rule 34 (type -> VECTOR OF type .)
    THEN            reduce using rule 34 (type -> VECTOR OF type .)
    COMMA           reduce using rule 34 (type -> VECTOR OF type .)
    UNTIL           reduce using rule 34 (type -> VECTOR OF type .)
    ELSE            reduce using rule 34 (type -> VECTOR OF type .)
    RBRACKET        reduce using rule 34 (type -> VECTOR OF type .)
    R_QBRACKET      reduce using rule 34 (type -> VECTOR OF type .)
    CONTINUE        reduce using rule 34 (type -> VECTOR OF type .)


state 138

    (74) math_expression -> expression LESS expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    NEWLINE         reduce using rule 74 (math_expression -> expression LESS expression .)
    LESS            reduce using rule 74 (math_expression -> expression LESS expression .)
    GREATER         reduce using rule 74 (math_expression -> expression LESS expression .)
    EQ              reduce using rule 74 (math_expression -> expression LESS expression .)
    NOTEQ           reduce using rule 74 (math_expression -> expression LESS expression .)
    TO              reduce using rule 74 (math_expression -> expression LESS expression .)
    THEN            reduce using rule 74 (math_expression -> expression LESS expression .)
    COMMA           reduce using rule 74 (math_expression -> expression LESS expression .)
    UNTIL           reduce using rule 74 (math_expression -> expression LESS expression .)
    ELSE            reduce using rule 74 (math_expression -> expression LESS expression .)
    RBRACKET        reduce using rule 74 (math_expression -> expression LESS expression .)
    R_QBRACKET      reduce using rule 74 (math_expression -> expression LESS expression .)
    error           reduce using rule 74 (math_expression -> expression LESS expression .)
    CONTINUE        reduce using rule 74 (math_expression -> expression LESS expression .)
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108

  ! PLUS            [ reduce using rule 74 (math_expression -> expression LESS expression .) ]
  ! MINUS           [ reduce using rule 74 (math_expression -> expression LESS expression .) ]
  ! LESS            [ shift and go to state 103 ]
  ! GREATER         [ shift and go to state 104 ]
  ! EQ              [ shift and go to state 105 ]
  ! NOTEQ           [ shift and go to state 106 ]
  ! TO              [ shift and go to state 109 ]


state 139

    (75) math_expression -> expression GREATER expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    NEWLINE         reduce using rule 75 (math_expression -> expression GREATER expression .)
    LESS            reduce using rule 75 (math_expression -> expression GREATER expression .)
    GREATER         reduce using rule 75 (math_expression -> expression GREATER expression .)
    EQ              reduce using rule 75 (math_expression -> expression GREATER expression .)
    NOTEQ           reduce using rule 75 (math_expression -> expression GREATER expression .)
    TO              reduce using rule 75 (math_expression -> expression GREATER expression .)
    THEN            reduce using rule 75 (math_expression -> expression GREATER expression .)
    COMMA           reduce using rule 75 (math_expression -> expression GREATER expression .)
    UNTIL           reduce using rule 75 (math_expression -> expression GREATER expression .)
    ELSE            reduce using rule 75 (math_expression -> expression GREATER expression .)
    RBRACKET        reduce using rule 75 (math_expression -> expression GREATER expression .)
    R_QBRACKET      reduce using rule 75 (math_expression -> expression GREATER expression .)
    error           reduce using rule 75 (math_expression -> expression GREATER expression .)
    CONTINUE        reduce using rule 75 (math_expression -> expression GREATER expression .)
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108

  ! PLUS            [ reduce using rule 75 (math_expression -> expression GREATER expression .) ]
  ! MINUS           [ reduce using rule 75 (math_expression -> expression GREATER expression .) ]
  ! LESS            [ shift and go to state 103 ]
  ! GREATER         [ shift and go to state 104 ]
  ! EQ              [ shift and go to state 105 ]
  ! NOTEQ           [ shift and go to state 106 ]
  ! TO              [ shift and go to state 109 ]


state 140

    (76) math_expression -> expression EQ expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    NEWLINE         reduce using rule 76 (math_expression -> expression EQ expression .)
    LESS            reduce using rule 76 (math_expression -> expression EQ expression .)
    GREATER         reduce using rule 76 (math_expression -> expression EQ expression .)
    EQ              reduce using rule 76 (math_expression -> expression EQ expression .)
    NOTEQ           reduce using rule 76 (math_expression -> expression EQ expression .)
    TO              reduce using rule 76 (math_expression -> expression EQ expression .)
    THEN            reduce using rule 76 (math_expression -> expression EQ expression .)
    COMMA           reduce using rule 76 (math_expression -> expression EQ expression .)
    UNTIL           reduce using rule 76 (math_expression -> expression EQ expression .)
    ELSE            reduce using rule 76 (math_expression -> expression EQ expression .)
    RBRACKET        reduce using rule 76 (math_expression -> expression EQ expression .)
    R_QBRACKET      reduce using rule 76 (math_expression -> expression EQ expression .)
    error           reduce using rule 76 (math_expression -> expression EQ expression .)
    CONTINUE        reduce using rule 76 (math_expression -> expression EQ expression .)
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108

  ! PLUS            [ reduce using rule 76 (math_expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 76 (math_expression -> expression EQ expression .) ]
  ! LESS            [ shift and go to state 103 ]
  ! GREATER         [ shift and go to state 104 ]
  ! EQ              [ shift and go to state 105 ]
  ! NOTEQ           [ shift and go to state 106 ]
  ! TO              [ shift and go to state 109 ]


state 141

    (77) math_expression -> expression NOTEQ expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    NEWLINE         reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    LESS            reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    GREATER         reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    EQ              reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    NOTEQ           reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    TO              reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    THEN            reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    COMMA           reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    UNTIL           reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    ELSE            reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    RBRACKET        reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    R_QBRACKET      reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    error           reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    CONTINUE        reduce using rule 77 (math_expression -> expression NOTEQ expression .)
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108

  ! PLUS            [ reduce using rule 77 (math_expression -> expression NOTEQ expression .) ]
  ! MINUS           [ reduce using rule 77 (math_expression -> expression NOTEQ expression .) ]
  ! LESS            [ shift and go to state 103 ]
  ! GREATER         [ shift and go to state 104 ]
  ! EQ              [ shift and go to state 105 ]
  ! NOTEQ           [ shift and go to state 106 ]
  ! TO              [ shift and go to state 109 ]


state 142

    (78) math_expression -> expression PLUS expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    NEWLINE         reduce using rule 78 (math_expression -> expression PLUS expression .)
    LESS            reduce using rule 78 (math_expression -> expression PLUS expression .)
    GREATER         reduce using rule 78 (math_expression -> expression PLUS expression .)
    EQ              reduce using rule 78 (math_expression -> expression PLUS expression .)
    NOTEQ           reduce using rule 78 (math_expression -> expression PLUS expression .)
    PLUS            reduce using rule 78 (math_expression -> expression PLUS expression .)
    MINUS           reduce using rule 78 (math_expression -> expression PLUS expression .)
    TO              reduce using rule 78 (math_expression -> expression PLUS expression .)
    THEN            reduce using rule 78 (math_expression -> expression PLUS expression .)
    COMMA           reduce using rule 78 (math_expression -> expression PLUS expression .)
    UNTIL           reduce using rule 78 (math_expression -> expression PLUS expression .)
    ELSE            reduce using rule 78 (math_expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 78 (math_expression -> expression PLUS expression .)
    R_QBRACKET      reduce using rule 78 (math_expression -> expression PLUS expression .)
    error           reduce using rule 78 (math_expression -> expression PLUS expression .)
    CONTINUE        reduce using rule 78 (math_expression -> expression PLUS expression .)

  ! LESS            [ shift and go to state 103 ]
  ! GREATER         [ shift and go to state 104 ]
  ! EQ              [ shift and go to state 105 ]
  ! NOTEQ           [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 108 ]
  ! TO              [ shift and go to state 109 ]


state 143

    (79) math_expression -> expression MINUS expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    NEWLINE         reduce using rule 79 (math_expression -> expression MINUS expression .)
    LESS            reduce using rule 79 (math_expression -> expression MINUS expression .)
    GREATER         reduce using rule 79 (math_expression -> expression MINUS expression .)
    EQ              reduce using rule 79 (math_expression -> expression MINUS expression .)
    NOTEQ           reduce using rule 79 (math_expression -> expression MINUS expression .)
    PLUS            reduce using rule 79 (math_expression -> expression MINUS expression .)
    MINUS           reduce using rule 79 (math_expression -> expression MINUS expression .)
    TO              reduce using rule 79 (math_expression -> expression MINUS expression .)
    THEN            reduce using rule 79 (math_expression -> expression MINUS expression .)
    COMMA           reduce using rule 79 (math_expression -> expression MINUS expression .)
    UNTIL           reduce using rule 79 (math_expression -> expression MINUS expression .)
    ELSE            reduce using rule 79 (math_expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 79 (math_expression -> expression MINUS expression .)
    R_QBRACKET      reduce using rule 79 (math_expression -> expression MINUS expression .)
    error           reduce using rule 79 (math_expression -> expression MINUS expression .)
    CONTINUE        reduce using rule 79 (math_expression -> expression MINUS expression .)

  ! LESS            [ shift and go to state 103 ]
  ! GREATER         [ shift and go to state 104 ]
  ! EQ              [ shift and go to state 105 ]
  ! NOTEQ           [ shift and go to state 106 ]
  ! PLUS            [ shift and go to state 107 ]
  ! MINUS           [ shift and go to state 108 ]
  ! TO              [ shift and go to state 109 ]


state 144

    (95) converting_command -> expression TO expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    NEWLINE         reduce using rule 95 (converting_command -> expression TO expression .)
    THEN            reduce using rule 95 (converting_command -> expression TO expression .)
    COMMA           reduce using rule 95 (converting_command -> expression TO expression .)
    UNTIL           reduce using rule 95 (converting_command -> expression TO expression .)
    ELSE            reduce using rule 95 (converting_command -> expression TO expression .)
    RBRACKET        reduce using rule 95 (converting_command -> expression TO expression .)
    R_QBRACKET      reduce using rule 95 (converting_command -> expression TO expression .)
    error           reduce using rule 95 (converting_command -> expression TO expression .)
    CONTINUE        reduce using rule 95 (converting_command -> expression TO expression .)
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109

  ! LESS            [ reduce using rule 95 (converting_command -> expression TO expression .) ]
  ! GREATER         [ reduce using rule 95 (converting_command -> expression TO expression .) ]
  ! EQ              [ reduce using rule 95 (converting_command -> expression TO expression .) ]
  ! NOTEQ           [ reduce using rule 95 (converting_command -> expression TO expression .) ]
  ! PLUS            [ reduce using rule 95 (converting_command -> expression TO expression .) ]
  ! MINUS           [ reduce using rule 95 (converting_command -> expression TO expression .) ]
  ! TO              [ reduce using rule 95 (converting_command -> expression TO expression .) ]


state 145

    (94) converting_command -> expression TO type .

    NEWLINE         reduce using rule 94 (converting_command -> expression TO type .)
    LESS            reduce using rule 94 (converting_command -> expression TO type .)
    GREATER         reduce using rule 94 (converting_command -> expression TO type .)
    EQ              reduce using rule 94 (converting_command -> expression TO type .)
    NOTEQ           reduce using rule 94 (converting_command -> expression TO type .)
    PLUS            reduce using rule 94 (converting_command -> expression TO type .)
    MINUS           reduce using rule 94 (converting_command -> expression TO type .)
    TO              reduce using rule 94 (converting_command -> expression TO type .)
    THEN            reduce using rule 94 (converting_command -> expression TO type .)
    COMMA           reduce using rule 94 (converting_command -> expression TO type .)
    UNTIL           reduce using rule 94 (converting_command -> expression TO type .)
    ELSE            reduce using rule 94 (converting_command -> expression TO type .)
    RBRACKET        reduce using rule 94 (converting_command -> expression TO type .)
    R_QBRACKET      reduce using rule 94 (converting_command -> expression TO type .)
    error           reduce using rule 94 (converting_command -> expression TO type .)
    CONTINUE        reduce using rule 94 (converting_command -> expression TO type .)


state 146

    (96) converting_command -> expression TO vector_of .

    NEWLINE         reduce using rule 96 (converting_command -> expression TO vector_of .)
    LESS            reduce using rule 96 (converting_command -> expression TO vector_of .)
    GREATER         reduce using rule 96 (converting_command -> expression TO vector_of .)
    EQ              reduce using rule 96 (converting_command -> expression TO vector_of .)
    NOTEQ           reduce using rule 96 (converting_command -> expression TO vector_of .)
    PLUS            reduce using rule 96 (converting_command -> expression TO vector_of .)
    MINUS           reduce using rule 96 (converting_command -> expression TO vector_of .)
    TO              reduce using rule 96 (converting_command -> expression TO vector_of .)
    THEN            reduce using rule 96 (converting_command -> expression TO vector_of .)
    COMMA           reduce using rule 96 (converting_command -> expression TO vector_of .)
    UNTIL           reduce using rule 96 (converting_command -> expression TO vector_of .)
    ELSE            reduce using rule 96 (converting_command -> expression TO vector_of .)
    RBRACKET        reduce using rule 96 (converting_command -> expression TO vector_of .)
    R_QBRACKET      reduce using rule 96 (converting_command -> expression TO vector_of .)
    error           reduce using rule 96 (converting_command -> expression TO vector_of .)
    CONTINUE        reduce using rule 96 (converting_command -> expression TO vector_of .)


state 147

    (34) type -> VECTOR . OF type
    (97) vector_of -> VECTOR . OF vector_of
    (98) vector_of -> VECTOR .

    OF              shift and go to state 171
    NEWLINE         reduce using rule 98 (vector_of -> VECTOR .)
    LESS            reduce using rule 98 (vector_of -> VECTOR .)
    GREATER         reduce using rule 98 (vector_of -> VECTOR .)
    EQ              reduce using rule 98 (vector_of -> VECTOR .)
    NOTEQ           reduce using rule 98 (vector_of -> VECTOR .)
    PLUS            reduce using rule 98 (vector_of -> VECTOR .)
    MINUS           reduce using rule 98 (vector_of -> VECTOR .)
    TO              reduce using rule 98 (vector_of -> VECTOR .)
    THEN            reduce using rule 98 (vector_of -> VECTOR .)
    COMMA           reduce using rule 98 (vector_of -> VECTOR .)
    UNTIL           reduce using rule 98 (vector_of -> VECTOR .)
    ELSE            reduce using rule 98 (vector_of -> VECTOR .)
    RBRACKET        reduce using rule 98 (vector_of -> VECTOR .)
    R_QBRACKET      reduce using rule 98 (vector_of -> VECTOR .)
    error           reduce using rule 98 (vector_of -> VECTOR .)
    CONTINUE        reduce using rule 98 (vector_of -> VECTOR .)


state 148

    (103) vector_pop -> variable POP BACK .

    NEWLINE         reduce using rule 103 (vector_pop -> variable POP BACK .)
    LESS            reduce using rule 103 (vector_pop -> variable POP BACK .)
    GREATER         reduce using rule 103 (vector_pop -> variable POP BACK .)
    EQ              reduce using rule 103 (vector_pop -> variable POP BACK .)
    NOTEQ           reduce using rule 103 (vector_pop -> variable POP BACK .)
    PLUS            reduce using rule 103 (vector_pop -> variable POP BACK .)
    MINUS           reduce using rule 103 (vector_pop -> variable POP BACK .)
    TO              reduce using rule 103 (vector_pop -> variable POP BACK .)
    THEN            reduce using rule 103 (vector_pop -> variable POP BACK .)
    COMMA           reduce using rule 103 (vector_pop -> variable POP BACK .)
    UNTIL           reduce using rule 103 (vector_pop -> variable POP BACK .)
    ELSE            reduce using rule 103 (vector_pop -> variable POP BACK .)
    RBRACKET        reduce using rule 103 (vector_pop -> variable POP BACK .)
    R_QBRACKET      reduce using rule 103 (vector_pop -> variable POP BACK .)
    error           reduce using rule 103 (vector_pop -> variable POP BACK .)
    CONTINUE        reduce using rule 103 (vector_pop -> variable POP BACK .)


state 149

    (104) vector_pop -> variable POP FRONT .

    NEWLINE         reduce using rule 104 (vector_pop -> variable POP FRONT .)
    LESS            reduce using rule 104 (vector_pop -> variable POP FRONT .)
    GREATER         reduce using rule 104 (vector_pop -> variable POP FRONT .)
    EQ              reduce using rule 104 (vector_pop -> variable POP FRONT .)
    NOTEQ           reduce using rule 104 (vector_pop -> variable POP FRONT .)
    PLUS            reduce using rule 104 (vector_pop -> variable POP FRONT .)
    MINUS           reduce using rule 104 (vector_pop -> variable POP FRONT .)
    TO              reduce using rule 104 (vector_pop -> variable POP FRONT .)
    THEN            reduce using rule 104 (vector_pop -> variable POP FRONT .)
    COMMA           reduce using rule 104 (vector_pop -> variable POP FRONT .)
    UNTIL           reduce using rule 104 (vector_pop -> variable POP FRONT .)
    ELSE            reduce using rule 104 (vector_pop -> variable POP FRONT .)
    RBRACKET        reduce using rule 104 (vector_pop -> variable POP FRONT .)
    R_QBRACKET      reduce using rule 104 (vector_pop -> variable POP FRONT .)
    error           reduce using rule 104 (vector_pop -> variable POP FRONT .)
    CONTINUE        reduce using rule 104 (vector_pop -> variable POP FRONT .)


state 150

    (54) qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .

    NEWLINE         reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    LESS            reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    GREATER         reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    EQ              reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    NOTEQ           reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    PLUS            reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    MINUS           reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    TO              reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    THEN            reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    COMMA           reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    UNTIL           reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    ELSE            reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    RBRACKET        reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    R_QBRACKET      reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    error           reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)
    CONTINUE        reduce using rule 54 (qstring -> DOUBLE_QUOTE string DOUBLE_QUOTE .)


state 151

    (56) string -> VARIABLE string .

    DOUBLE_QUOTE    reduce using rule 56 (string -> VARIABLE string .)
    QUOTE           reduce using rule 56 (string -> VARIABLE string .)


state 152

    (57) string -> DECIMAL string .

    DOUBLE_QUOTE    reduce using rule 57 (string -> DECIMAL string .)
    QUOTE           reduce using rule 57 (string -> DECIMAL string .)


state 153

    (58) string -> FALSE string .

    DOUBLE_QUOTE    reduce using rule 58 (string -> FALSE string .)
    QUOTE           reduce using rule 58 (string -> FALSE string .)


state 154

    (59) string -> TRUE string .

    DOUBLE_QUOTE    reduce using rule 59 (string -> TRUE string .)
    QUOTE           reduce using rule 59 (string -> TRUE string .)


state 155

    (55) qstring -> QUOTE string QUOTE .

    NEWLINE         reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    LESS            reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    GREATER         reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    EQ              reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    NOTEQ           reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    PLUS            reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    MINUS           reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    TO              reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    THEN            reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    COMMA           reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    UNTIL           reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    ELSE            reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    RBRACKET        reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    R_QBRACKET      reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    error           reduce using rule 55 (qstring -> QUOTE string QUOTE .)
    CONTINUE        reduce using rule 55 (qstring -> QUOTE string QUOTE .)


state 156

    (35) variables -> variable COMMA variables .

    NEWLINE         reduce using rule 35 (variables -> variable COMMA variables .)
    UNTIL           reduce using rule 35 (variables -> variable COMMA variables .)
    ELSE            reduce using rule 35 (variables -> variable COMMA variables .)


state 157

    (36) variables -> assignment COMMA variables .

    NEWLINE         reduce using rule 36 (variables -> assignment COMMA variables .)
    UNTIL           reduce using rule 36 (variables -> assignment COMMA variables .)
    ELSE            reduce using rule 36 (variables -> assignment COMMA variables .)


state 158

    (99) vector_command -> variable PUSH BACK expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    error           reduce using rule 99 (vector_command -> variable PUSH BACK expression .)
    NEWLINE         reduce using rule 99 (vector_command -> variable PUSH BACK expression .)
    UNTIL           reduce using rule 99 (vector_command -> variable PUSH BACK expression .)
    ELSE            reduce using rule 99 (vector_command -> variable PUSH BACK expression .)
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109


state 159

    (101) vector_command -> variable PUSH BACK error .

    error           reduce using rule 101 (vector_command -> variable PUSH BACK error .)
    NEWLINE         reduce using rule 101 (vector_command -> variable PUSH BACK error .)
    UNTIL           reduce using rule 101 (vector_command -> variable PUSH BACK error .)
    ELSE            reduce using rule 101 (vector_command -> variable PUSH BACK error .)


state 160

    (100) vector_command -> variable PUSH FRONT expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    error           reduce using rule 100 (vector_command -> variable PUSH FRONT expression .)
    NEWLINE         reduce using rule 100 (vector_command -> variable PUSH FRONT expression .)
    UNTIL           reduce using rule 100 (vector_command -> variable PUSH FRONT expression .)
    ELSE            reduce using rule 100 (vector_command -> variable PUSH FRONT expression .)
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109


state 161

    (102) vector_command -> variable PUSH FRONT error .

    error           reduce using rule 102 (vector_command -> variable PUSH FRONT error .)
    NEWLINE         reduce using rule 102 (vector_command -> variable PUSH FRONT error .)
    UNTIL           reduce using rule 102 (vector_command -> variable PUSH FRONT error .)
    ELSE            reduce using rule 102 (vector_command -> variable PUSH FRONT error .)


state 162

    (80) while -> DO statements_group UNTIL expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    NEWLINE         reduce using rule 80 (while -> DO statements_group UNTIL expression .)
    UNTIL           reduce using rule 80 (while -> DO statements_group UNTIL expression .)
    ELSE            reduce using rule 80 (while -> DO statements_group UNTIL expression .)
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109


state 163

    (2) statements_group -> BEGIN statements END .

    UNTIL           reduce using rule 2 (statements_group -> BEGIN statements END .)
    ELSE            reduce using rule 2 (statements_group -> BEGIN statements END .)
    NEWLINE         reduce using rule 2 (statements_group -> BEGIN statements END .)


state 164

    (82) if -> IF expression THEN statements_group .
    (83) if -> IF expression THEN statements_group . ELSE statements_group

    NEWLINE         reduce using rule 82 (if -> IF expression THEN statements_group .)
    UNTIL           reduce using rule 82 (if -> IF expression THEN statements_group .)
    ELSE            shift and go to state 172

  ! ELSE            [ reduce using rule 82 (if -> IF expression THEN statements_group .) ]


state 165

    (85) function -> FUNCTION OF type VARIABLE . LBRACKET parameters RBRACKET statements_group
    (86) function -> FUNCTION OF type VARIABLE . BRACKETS statements_group
    (87) function -> FUNCTION OF type VARIABLE . LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> FUNCTION OF type VARIABLE . LBRACKET CONTINUE RBRACKET statements_group

    LBRACKET        shift and go to state 173
    BRACKETS        shift and go to state 174


state 166

    (121) parameter -> VARIABLE EQ . expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 55
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    expression                     shift and go to state 175
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 167

    (114) call -> VARIABLE LBRACKET parameters RBRACKET .

    NEWLINE         reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    LESS            reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    GREATER         reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    EQ              reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    NOTEQ           reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    PLUS            reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    MINUS           reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    TO              reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    UNTIL           reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    THEN            reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    COMMA           reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    ELSE            reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    RBRACKET        reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    R_QBRACKET      reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    error           reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)
    CONTINUE        reduce using rule 114 (call -> VARIABLE LBRACKET parameters RBRACKET .)


state 168

    (118) parameters -> parameters COMMA . parameter
    (120) parameter -> . expression
    (121) parameter -> . VARIABLE EQ expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    VARIABLE        shift and go to state 131
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    parameter                      shift and go to state 176
    expression                     shift and go to state 135
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 169

    (116) call -> VARIABLE LBRACKET error RBRACKET .

    NEWLINE         reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    LESS            reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    GREATER         reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    EQ              reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    NOTEQ           reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    PLUS            reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    MINUS           reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    TO              reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    UNTIL           reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    THEN            reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    COMMA           reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    ELSE            reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    RBRACKET        reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    R_QBRACKET      reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    error           reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)
    CONTINUE        reduce using rule 116 (call -> VARIABLE LBRACKET error RBRACKET .)


state 170

    (44) indexing -> L_QBRACKET expression R_QBRACKET . indexing
    (45) indexing -> L_QBRACKET expression R_QBRACKET .
    (44) indexing -> . L_QBRACKET expression R_QBRACKET indexing
    (45) indexing -> . L_QBRACKET expression R_QBRACKET

    ASSIGNMENT      reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    PUSH            reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    POP             reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    NEWLINE         reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    LESS            reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    GREATER         reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    EQ              reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    NOTEQ           reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    PLUS            reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    MINUS           reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    TO              reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    THEN            reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    COMMA           reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    UNTIL           reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    ELSE            reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    R_QBRACKET      reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    RBRACKET        reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    error           reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    CONTINUE        reduce using rule 45 (indexing -> L_QBRACKET expression R_QBRACKET .)
    L_QBRACKET      shift and go to state 100

    indexing                       shift and go to state 177

state 171

    (34) type -> VECTOR OF . type
    (97) vector_of -> VECTOR OF . vector_of
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (97) vector_of -> . VECTOR OF vector_of
    (98) vector_of -> . VECTOR

    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 147

    type                           shift and go to state 137
    vector_of                      shift and go to state 178

state 172

    (83) if -> IF expression THEN statements_group ELSE . statements_group
    (2) statements_group -> . BEGIN statements END
    (3) statements_group -> . inner_statement
    (4) inner_statement -> . declaration
    (5) inner_statement -> . assignment
    (6) inner_statement -> . while
    (7) inner_statement -> . if
    (8) inner_statement -> . command
    (9) inner_statement -> . function
    (10) inner_statement -> . call
    (11) inner_statement -> . RETURN expression
    (12) inner_statement -> . empty
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    BEGIN           shift and go to state 80
    RETURN          shift and go to state 89
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    ELSE            reduce using rule 117 (empty -> .)
    NEWLINE         reduce using rule 117 (empty -> .)
    UNTIL           reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    statements_group               shift and go to state 179
    inner_statement                shift and go to state 81
    declaration                    shift and go to state 82
    assignment                     shift and go to state 83
    while                          shift and go to state 84
    if                             shift and go to state 85
    command                        shift and go to state 86
    function                       shift and go to state 87
    call                           shift and go to state 88
    empty                          shift and go to state 90
    type                           shift and go to state 15
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 173

    (85) function -> FUNCTION OF type VARIABLE LBRACKET . parameters RBRACKET statements_group
    (87) function -> FUNCTION OF type VARIABLE LBRACKET . parameters CONTINUE RBRACKET statements_group
    (88) function -> FUNCTION OF type VARIABLE LBRACKET . CONTINUE RBRACKET statements_group
    (118) parameters -> . parameters COMMA parameter
    (119) parameters -> . parameter
    (120) parameter -> . expression
    (121) parameter -> . VARIABLE EQ expression
    (46) expression -> . variable
    (47) expression -> . const
    (48) expression -> . qstring
    (49) expression -> . math_expression
    (50) expression -> . robot_command
    (51) expression -> . converting_command
    (52) expression -> . vector_pop
    (53) expression -> . call
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (64) const -> . TRUE
    (65) const -> . FALSE
    (66) const -> . UNDEFINED
    (67) const -> . DECIMAL
    (68) const -> . EXIT
    (69) const -> . WOOD
    (70) const -> . STEEL
    (71) const -> . GLASS
    (72) const -> . CONCRETE
    (73) const -> . PLASTIC
    (54) qstring -> . DOUBLE_QUOTE string DOUBLE_QUOTE
    (55) qstring -> . QUOTE string QUOTE
    (74) math_expression -> . expression LESS expression
    (75) math_expression -> . expression GREATER expression
    (76) math_expression -> . expression EQ expression
    (77) math_expression -> . expression NOTEQ expression
    (78) math_expression -> . expression PLUS expression
    (79) math_expression -> . expression MINUS expression
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL
    (94) converting_command -> . expression TO type
    (95) converting_command -> . expression TO expression
    (96) converting_command -> . expression TO vector_of
    (103) vector_pop -> . variable POP BACK
    (104) vector_pop -> . variable POP FRONT
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET

    CONTINUE        shift and go to state 181
    VARIABLE        shift and go to state 131
    TRUE            shift and go to state 56
    FALSE           shift and go to state 57
    UNDEFINED       shift and go to state 58
    DECIMAL         shift and go to state 59
    EXIT            shift and go to state 60
    WOOD            shift and go to state 61
    STEEL           shift and go to state 62
    GLASS           shift and go to state 63
    CONCRETE        shift and go to state 64
    PLASTIC         shift and go to state 65
    DOUBLE_QUOTE    shift and go to state 66
    QUOTE           shift and go to state 67
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    parameters                     shift and go to state 180
    parameter                      shift and go to state 134
    expression                     shift and go to state 135
    variable                       shift and go to state 47
    const                          shift and go to state 48
    qstring                        shift and go to state 49
    math_expression                shift and go to state 50
    robot_command                  shift and go to state 51
    converting_command             shift and go to state 52
    vector_pop                     shift and go to state 53
    call                           shift and go to state 54

state 174

    (86) function -> FUNCTION OF type VARIABLE BRACKETS . statements_group
    (2) statements_group -> . BEGIN statements END
    (3) statements_group -> . inner_statement
    (4) inner_statement -> . declaration
    (5) inner_statement -> . assignment
    (6) inner_statement -> . while
    (7) inner_statement -> . if
    (8) inner_statement -> . command
    (9) inner_statement -> . function
    (10) inner_statement -> . call
    (11) inner_statement -> . RETURN expression
    (12) inner_statement -> . empty
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    BEGIN           shift and go to state 80
    RETURN          shift and go to state 89
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    ELSE            reduce using rule 117 (empty -> .)
    NEWLINE         reduce using rule 117 (empty -> .)
    UNTIL           reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    type                           shift and go to state 15
    statements_group               shift and go to state 182
    inner_statement                shift and go to state 81
    declaration                    shift and go to state 82
    assignment                     shift and go to state 83
    while                          shift and go to state 84
    if                             shift and go to state 85
    command                        shift and go to state 86
    function                       shift and go to state 87
    call                           shift and go to state 88
    empty                          shift and go to state 90
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 175

    (121) parameter -> VARIABLE EQ expression .
    (74) math_expression -> expression . LESS expression
    (75) math_expression -> expression . GREATER expression
    (76) math_expression -> expression . EQ expression
    (77) math_expression -> expression . NOTEQ expression
    (78) math_expression -> expression . PLUS expression
    (79) math_expression -> expression . MINUS expression
    (94) converting_command -> expression . TO type
    (95) converting_command -> expression . TO expression
    (96) converting_command -> expression . TO vector_of

    RBRACKET        reduce using rule 121 (parameter -> VARIABLE EQ expression .)
    COMMA           reduce using rule 121 (parameter -> VARIABLE EQ expression .)
    CONTINUE        reduce using rule 121 (parameter -> VARIABLE EQ expression .)
    LESS            shift and go to state 103
    GREATER         shift and go to state 104
    EQ              shift and go to state 105
    NOTEQ           shift and go to state 106
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TO              shift and go to state 109


state 176

    (118) parameters -> parameters COMMA parameter .

    RBRACKET        reduce using rule 118 (parameters -> parameters COMMA parameter .)
    COMMA           reduce using rule 118 (parameters -> parameters COMMA parameter .)
    CONTINUE        reduce using rule 118 (parameters -> parameters COMMA parameter .)


state 177

    (44) indexing -> L_QBRACKET expression R_QBRACKET indexing .

    ASSIGNMENT      reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    PUSH            reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    POP             reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    NEWLINE         reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    LESS            reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    GREATER         reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    EQ              reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    NOTEQ           reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    PLUS            reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    MINUS           reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    TO              reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    THEN            reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    COMMA           reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    UNTIL           reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    ELSE            reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    R_QBRACKET      reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    RBRACKET        reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    error           reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)
    CONTINUE        reduce using rule 44 (indexing -> L_QBRACKET expression R_QBRACKET indexing .)


state 178

    (97) vector_of -> VECTOR OF vector_of .

    NEWLINE         reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    LESS            reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    GREATER         reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    EQ              reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    NOTEQ           reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    PLUS            reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    MINUS           reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    TO              reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    THEN            reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    COMMA           reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    UNTIL           reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    ELSE            reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    RBRACKET        reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    R_QBRACKET      reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    error           reduce using rule 97 (vector_of -> VECTOR OF vector_of .)
    CONTINUE        reduce using rule 97 (vector_of -> VECTOR OF vector_of .)


state 179

    (83) if -> IF expression THEN statements_group ELSE statements_group .

    NEWLINE         reduce using rule 83 (if -> IF expression THEN statements_group ELSE statements_group .)
    UNTIL           reduce using rule 83 (if -> IF expression THEN statements_group ELSE statements_group .)
    ELSE            reduce using rule 83 (if -> IF expression THEN statements_group ELSE statements_group .)


state 180

    (85) function -> FUNCTION OF type VARIABLE LBRACKET parameters . RBRACKET statements_group
    (87) function -> FUNCTION OF type VARIABLE LBRACKET parameters . CONTINUE RBRACKET statements_group
    (118) parameters -> parameters . COMMA parameter

    RBRACKET        shift and go to state 183
    CONTINUE        shift and go to state 184
    COMMA           shift and go to state 168


state 181

    (88) function -> FUNCTION OF type VARIABLE LBRACKET CONTINUE . RBRACKET statements_group

    RBRACKET        shift and go to state 185


state 182

    (86) function -> FUNCTION OF type VARIABLE BRACKETS statements_group .

    NEWLINE         reduce using rule 86 (function -> FUNCTION OF type VARIABLE BRACKETS statements_group .)
    UNTIL           reduce using rule 86 (function -> FUNCTION OF type VARIABLE BRACKETS statements_group .)
    ELSE            reduce using rule 86 (function -> FUNCTION OF type VARIABLE BRACKETS statements_group .)


state 183

    (85) function -> FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET . statements_group
    (2) statements_group -> . BEGIN statements END
    (3) statements_group -> . inner_statement
    (4) inner_statement -> . declaration
    (5) inner_statement -> . assignment
    (6) inner_statement -> . while
    (7) inner_statement -> . if
    (8) inner_statement -> . command
    (9) inner_statement -> . function
    (10) inner_statement -> . call
    (11) inner_statement -> . RETURN expression
    (12) inner_statement -> . empty
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    BEGIN           shift and go to state 80
    RETURN          shift and go to state 89
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    ELSE            reduce using rule 117 (empty -> .)
    NEWLINE         reduce using rule 117 (empty -> .)
    UNTIL           reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    type                           shift and go to state 15
    statements_group               shift and go to state 186
    inner_statement                shift and go to state 81
    declaration                    shift and go to state 82
    assignment                     shift and go to state 83
    while                          shift and go to state 84
    if                             shift and go to state 85
    command                        shift and go to state 86
    function                       shift and go to state 87
    call                           shift and go to state 88
    empty                          shift and go to state 90
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 184

    (87) function -> FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE . RBRACKET statements_group

    RBRACKET        shift and go to state 187


state 185

    (88) function -> FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET . statements_group
    (2) statements_group -> . BEGIN statements END
    (3) statements_group -> . inner_statement
    (4) inner_statement -> . declaration
    (5) inner_statement -> . assignment
    (6) inner_statement -> . while
    (7) inner_statement -> . if
    (8) inner_statement -> . command
    (9) inner_statement -> . function
    (10) inner_statement -> . call
    (11) inner_statement -> . RETURN expression
    (12) inner_statement -> . empty
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    BEGIN           shift and go to state 80
    RETURN          shift and go to state 89
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    ELSE            reduce using rule 117 (empty -> .)
    NEWLINE         reduce using rule 117 (empty -> .)
    UNTIL           reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    type                           shift and go to state 15
    statements_group               shift and go to state 188
    inner_statement                shift and go to state 81
    declaration                    shift and go to state 82
    assignment                     shift and go to state 83
    while                          shift and go to state 84
    if                             shift and go to state 85
    command                        shift and go to state 86
    function                       shift and go to state 87
    call                           shift and go to state 88
    empty                          shift and go to state 90
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 186

    (85) function -> FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group .

    NEWLINE         reduce using rule 85 (function -> FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group .)
    UNTIL           reduce using rule 85 (function -> FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group .)
    ELSE            reduce using rule 85 (function -> FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group .)


state 187

    (87) function -> FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET . statements_group
    (2) statements_group -> . BEGIN statements END
    (3) statements_group -> . inner_statement
    (4) inner_statement -> . declaration
    (5) inner_statement -> . assignment
    (6) inner_statement -> . while
    (7) inner_statement -> . if
    (8) inner_statement -> . command
    (9) inner_statement -> . function
    (10) inner_statement -> . call
    (11) inner_statement -> . RETURN expression
    (12) inner_statement -> . empty
    (26) declaration -> . type variables
    (27) declaration -> . type error
    (39) assignment -> . variable ASSIGNMENT expression
    (40) assignment -> . variable ASSIGNMENT assignment
    (41) assignment -> . variable ASSIGNMENT error
    (80) while -> . DO statements_group UNTIL expression
    (81) while -> . DO error
    (82) if -> . IF expression THEN statements_group
    (83) if -> . IF expression THEN statements_group ELSE statements_group
    (84) if -> . IF error
    (90) command -> . vector_command
    (91) command -> . robot_command
    (92) command -> . vector_command error
    (93) command -> . robot_command error
    (85) function -> . FUNCTION OF type VARIABLE LBRACKET parameters RBRACKET statements_group
    (86) function -> . FUNCTION OF type VARIABLE BRACKETS statements_group
    (87) function -> . FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group
    (88) function -> . FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group
    (89) function -> . FUNCTION error
    (114) call -> . VARIABLE LBRACKET parameters RBRACKET
    (115) call -> . VARIABLE BRACKETS
    (116) call -> . VARIABLE LBRACKET error RBRACKET
    (117) empty -> .
    (31) type -> . INTEGER
    (32) type -> . STRING
    (33) type -> . BOOL
    (34) type -> . VECTOR OF type
    (42) variable -> . VARIABLE indexing
    (43) variable -> . VARIABLE
    (99) vector_command -> . variable PUSH BACK expression
    (100) vector_command -> . variable PUSH FRONT expression
    (101) vector_command -> . variable PUSH BACK error
    (102) vector_command -> . variable PUSH FRONT error
    (105) robot_command -> . LEFT
    (106) robot_command -> . RIGHT
    (107) robot_command -> . FORWARD
    (108) robot_command -> . BACK
    (109) robot_command -> . ROTATE_RIGHT
    (110) robot_command -> . ROTATE_LEFT
    (111) robot_command -> . LMS
    (112) robot_command -> . REFLECT
    (113) robot_command -> . DRILL

    BEGIN           shift and go to state 80
    RETURN          shift and go to state 89
    DO              shift and go to state 18
    IF              shift and go to state 19
    FUNCTION        shift and go to state 22
    VARIABLE        shift and go to state 23
    ELSE            reduce using rule 117 (empty -> .)
    NEWLINE         reduce using rule 117 (empty -> .)
    UNTIL           reduce using rule 117 (empty -> .)
    INTEGER         shift and go to state 24
    STRING          shift and go to state 25
    BOOL            shift and go to state 26
    VECTOR          shift and go to state 27
    LEFT            shift and go to state 29
    RIGHT           shift and go to state 30
    FORWARD         shift and go to state 31
    BACK            shift and go to state 28
    ROTATE_RIGHT    shift and go to state 32
    ROTATE_LEFT     shift and go to state 33
    LMS             shift and go to state 34
    REFLECT         shift and go to state 35
    DRILL           shift and go to state 36

    type                           shift and go to state 15
    statements_group               shift and go to state 189
    inner_statement                shift and go to state 81
    declaration                    shift and go to state 82
    assignment                     shift and go to state 83
    while                          shift and go to state 84
    if                             shift and go to state 85
    command                        shift and go to state 86
    function                       shift and go to state 87
    call                           shift and go to state 88
    empty                          shift and go to state 90
    variable                       shift and go to state 17
    vector_command                 shift and go to state 20
    robot_command                  shift and go to state 21

state 188

    (88) function -> FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group .

    NEWLINE         reduce using rule 88 (function -> FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group .)
    UNTIL           reduce using rule 88 (function -> FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group .)
    ELSE            reduce using rule 88 (function -> FUNCTION OF type VARIABLE LBRACKET CONTINUE RBRACKET statements_group .)


state 189

    (87) function -> FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group .

    NEWLINE         reduce using rule 87 (function -> FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group .)
    UNTIL           reduce using rule 87 (function -> FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group .)
    ELSE            reduce using rule 87 (function -> FUNCTION OF type VARIABLE LBRACKET parameters CONTINUE RBRACKET statements_group .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQ in state 131 resolved as shift
