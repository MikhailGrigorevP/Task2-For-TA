Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APPLICATION
    ASSIGMENT
    BACK
    BEGIN
    BOOL
    COMMA
    CONTINUE
    DO
    DOUBLE_QUOTE
    DRILL
    ELSE
    END
    EQ
    FALSE
    FORWARD
    FRONT
    FUNCTION_OF
    GREATER
    IF
    INTEGER
    INT_DEX
    LBRACKET
    LEFT
    LESS
    LMS
    L_QBRACKET
    MINUS
    NOTEQ
    OF
    PLUS
    POP
    PUSH
    QUOTE
    RBRACKET
    REFLECT
    RETURN
    RIGHT
    ROTATE_LEFT
    ROTATE_RIGHT
    R_QBRACKET
    SPACE
    STRING
    THEN
    TO
    TRUE
    UNDEFINED
    UNTIL
    VECTOR

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> VARIABLE NEWLINE

Terminals, with rules where they appear

APPLICATION          : 
ASSIGMENT            : 
BACK                 : 
BEGIN                : 
BOOL                 : 
COMMA                : 
CONTINUE             : 
DO                   : 
DOUBLE_QUOTE         : 
DRILL                : 
ELSE                 : 
END                  : 
EQ                   : 
FALSE                : 
FORWARD              : 
FRONT                : 
FUNCTION_OF          : 
GREATER              : 
IF                   : 
INTEGER              : 
INT_DEX              : 
LBRACKET             : 
LEFT                 : 
LESS                 : 
LMS                  : 
L_QBRACKET           : 
MINUS                : 
NEWLINE              : 2
NOTEQ                : 
OF                   : 
PLUS                 : 
POP                  : 
PUSH                 : 
QUOTE                : 
RBRACKET             : 
REFLECT              : 
RETURN               : 
RIGHT                : 
ROTATE_LEFT          : 
ROTATE_RIGHT         : 
R_QBRACKET           : 
SPACE                : 
STRING               : 
THEN                 : 
TO                   : 
TRUE                 : 
UNDEFINED            : 
UNTIL                : 
VARIABLE             : 2
VECTOR               : 
error                : 

Nonterminals, with rules where they appear

program              : 0
stmt_list            : 1

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> . VARIABLE NEWLINE

    VARIABLE        shift and go to state 3

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list .

    $end            reduce using rule 1 (program -> stmt_list .)


state 3

    (2) stmt_list -> VARIABLE . NEWLINE

    NEWLINE         shift and go to state 4


state 4

    (2) stmt_list -> VARIABLE NEWLINE .

    $end            reduce using rule 2 (stmt_list -> VARIABLE NEWLINE .)

